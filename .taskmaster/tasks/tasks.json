{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Vue 3 + TypeScript Project with Vite",
        "description": "Set up the foundational Vue 3 project using Vite with TypeScript, ESLint, Prettier, and Vitest configured. This establishes the development environment for all subsequent work.",
        "details": "1. Run `npm create vue@latest` with options:\n   - TypeScript: Yes\n   - JSX Support: No\n   - Vue Router: No (single-page, no routing needed for MVP)\n   - Pinia: No (start simple, add later if needed)\n   - Vitest: Yes\n   - ESLint + Prettier: Yes\n\n2. Configure `tsconfig.json` for strict mode:\n   ```json\n   {\n     \"compilerOptions\": {\n       \"strict\": true,\n       \"noImplicitAny\": true\n     }\n   }\n   ```\n\n3. Install Chart.js dependency:\n   ```bash\n   npm install chart.js\n   npm install -D @types/chart.js\n   ```\n\n4. Set up directory structure:\n   ```\n   src/\n   ├── core/\n   │   ├── models/\n   │   ├── calculations/\n   │   └── storage/\n   ├── components/\n   └── App.vue\n   ```\n\n5. Configure ESLint for Vue 3 + TypeScript:\n   - Extend `@vue/eslint-config-typescript`\n   - Enable recommended rules\n\n6. Verify setup:\n   - `npm run dev` starts server\n   - `npm run build` produces output\n   - `npm run type-check` passes\n   - `npm run lint` passes",
        "testStrategy": "1. Run `npm run dev` - dev server starts at localhost:5173\n2. Run `npm run build` - production build completes without errors\n3. Run `npm run type-check` - TypeScript compilation succeeds\n4. Run `npm run lint` - no linting errors\n5. Run `npm run test` - Vitest runs (even with no tests yet)\n6. Verify Chart.js imports work in a test component",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Vue 3 + TypeScript Project with Vite",
            "description": "Run npm create vue@latest to generate the base Vue 3 project with TypeScript, Vitest, ESLint, and Prettier enabled. Skip Vue Router and Pinia since they are not needed for MVP.",
            "dependencies": [],
            "details": "Execute `npm create vue@latest pharmacokinetics-grapher` (or run in current directory). Select options: TypeScript=Yes, JSX=No, Vue Router=No, Pinia=No, Vitest=Yes, E2E Testing=No, ESLint+Prettier=Yes. After scaffolding completes, run `npm install` to install all dependencies. Verify the generated structure includes: src/App.vue, src/main.ts, vite.config.ts, tsconfig.json, package.json with scripts for dev/build/test/lint.",
            "status": "pending",
            "testStrategy": "Run `npm run dev` and verify dev server starts at localhost:5173. Check that the default Vue welcome page renders in browser. Run `npm run build` to ensure production build succeeds without errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure TypeScript Strict Mode and Compiler Options",
            "description": "Update tsconfig.json to enable strict mode with noImplicitAny for enhanced type safety throughout the pharmacokinetics calculation codebase.",
            "dependencies": [
              1
            ],
            "details": "Edit tsconfig.json to ensure compilerOptions includes: \"strict\": true, \"noImplicitAny\": true, \"strictNullChecks\": true. Verify tsconfig.app.json and tsconfig.node.json extend the base config correctly. These settings ensure all prescription model types and calculation functions have explicit type annotations, preventing runtime errors in PK calculations.",
            "status": "pending",
            "testStrategy": "Run `npm run type-check` (vue-tsc --noEmit). Verify it passes without errors. Create a test file with an intentional implicit any (e.g., `const x = (a) => a`) and confirm type-check fails, proving strict mode is active.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Install and Configure Chart.js for Scientific Visualization",
            "description": "Add Chart.js dependency for rendering pharmacokinetic concentration curves. Chart.js was selected for its accuracy in scientific data visualization and lightweight footprint.",
            "dependencies": [
              1
            ],
            "details": "Run `npm install chart.js` to add the charting library. Note: @types/chart.js is NOT needed since Chart.js v3+ includes built-in TypeScript declarations. Verify installation by checking package.json dependencies include chart.js. The GraphViewer component (created in Task 7) will import from 'chart.js' directly using Chart.register(...registerables) pattern.",
            "status": "pending",
            "testStrategy": "Create a minimal test in src/chart-test.ts that imports { Chart, registerables } from 'chart.js' and calls Chart.register(...registerables). Run `npm run type-check` to verify imports resolve correctly. Delete test file after verification.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Core Application Directory Structure",
            "description": "Establish the src/core directory structure for models, calculations, and storage modules. This separates pharmacokinetic logic from Vue UI components.",
            "dependencies": [
              1
            ],
            "details": "Create the following directory structure under src/: src/core/models/ (for prescription.ts types), src/core/calculations/ (for pkCalculator.ts, multiDoseProfile.ts), src/core/storage/ (for prescriptionStorage.ts), and corresponding __tests__ folders: src/core/models/__tests__/, src/core/calculations/__tests__/, src/core/storage/__tests__/. Also create src/components/__tests__/ for Vue component tests. This structure enables clean separation between pure calculation functions and UI layer per CLAUDE.md architecture.",
            "status": "pending",
            "testStrategy": "Run `ls -R src/core` to verify all directories exist. Create placeholder index.ts files in each directory with export {} to ensure TypeScript recognizes them as modules. Run `npm run type-check` to confirm no path resolution errors.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify Complete Development Environment and Lint Configuration",
            "description": "Run all quality checks (dev server, build, type-check, lint, test) to confirm the development environment is fully functional before proceeding with prescription model implementation.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Execute verification commands in sequence: 1) `npm run dev` - starts Vite dev server at localhost:5173, 2) `npm run build` - generates dist/ production output, 3) `npm run type-check` - vue-tsc validates TypeScript, 4) `npm run lint` - ESLint + Prettier report no errors (run `npm run lint -- --fix` if needed), 5) `npm run test` - Vitest executes (passes with 0 tests initially). Ensure package.json scripts match expected command names. Update ESLint config if needed to extend @vue/eslint-config-typescript with recommended rules.",
            "status": "pending",
            "testStrategy": "Create a checklist and run each command, documenting exit codes. All commands must exit with code 0. Take a screenshot or capture output showing successful execution. Verify Chart.js import works by temporarily adding import statement to App.vue and confirming no TypeScript errors.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Already has 5 well-defined subtasks covering scaffolding, TypeScript config, Chart.js installation, directory structure, and verification. No further expansion needed.",
        "updatedAt": "2026-02-14T03:46:55.121Z"
      },
      {
        "id": "2",
        "title": "Implement Prescription Data Models and Validation",
        "description": "Create TypeScript type definitions for Prescription, TimeSeriesPoint, and GraphDataset interfaces. Implement comprehensive validation function with all field-level and logical constraints defined in PRD.",
        "details": "1. Create `src/core/models/prescription.ts`:\n   ```typescript\n   export type FrequencyLabel = 'once' | 'bid' | 'tid' | 'qid' | 'q6h' | 'q8h' | 'q12h' | 'custom';\n\n   export interface Prescription {\n     id?: string;\n     name: string;\n     frequency: FrequencyLabel;\n     times: string[];        // HH:MM format\n     dose: number;           // mg, units, etc.\n     halfLife: number;       // hours\n     metaboliteLife?: number; // optional\n     peak: number;           // Tmax in hours\n     uptake: number;         // absorption time in hours\n   }\n\n   export interface TimeSeriesPoint {\n     time: number;           // hours from start\n     concentration: number;  // 0-1 normalized\n   }\n\n   export interface GraphDataset {\n     label: string;\n     data: TimeSeriesPoint[];\n     color?: string;\n   }\n   ```\n\n2. Create frequency mapping constant:\n   ```typescript\n   export const FREQUENCY_COUNTS: Record<FrequencyLabel, number | null> = {\n     once: 1, bid: 2, tid: 3, qid: 4,\n     q6h: 4, q8h: 3, q12h: 2, custom: null\n   };\n   ```\n\n3. Implement validation function:\n   ```typescript\n   export interface ValidationResult {\n     valid: boolean;\n     errors: string[];\n     warnings: string[];\n   }\n\n   export function validatePrescription(rx: Prescription): ValidationResult\n   ```\n\n4. Validation rules:\n   - name: 1-100 chars, required\n   - dose: 0.001-10000, required\n   - halfLife: 0.1-240 hours, required\n   - peak: 0.1-48 hours, required\n   - uptake: 0.1-24 hours, required\n   - times: HH:MM format, count matches frequency\n   - Warning (not error) if uptake >= halfLife\n\n5. Time format validation helper:\n   ```typescript\n   function isValidTimeFormat(time: string): boolean {\n     const regex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;\n     return regex.test(time);\n   }\n   ```",
        "testStrategy": "Create `src/core/models/__tests__/prescription.spec.ts`:\n1. Test valid prescription passes validation\n2. Test invalid name (empty, too long) produces error\n3. Test invalid dose (0, negative, >10000) produces error\n4. Test invalid halfLife (0, <0.1, >240) produces error\n5. Test times count mismatch with frequency produces error\n6. Test invalid time format (25:00, abc) produces error\n7. Test uptake >= halfLife produces warning (not error)\n8. Test all edge cases: boundary values at min/max limits\n9. Run `npm run test src/core/models/__tests__/prescription.spec.ts`",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Core TypeScript Interfaces and FrequencyLabel Union Type",
            "description": "Create the prescription.ts file with Prescription, TimeSeriesPoint, and GraphDataset interfaces plus FrequencyLabel union type as specified in CLAUDE.md.",
            "dependencies": [],
            "details": "Create `src/core/models/prescription.ts` with:\n1. FrequencyLabel union type: 'once' | 'bid' | 'tid' | 'qid' | 'q6h' | 'q8h' | 'q12h' | 'custom'\n2. Prescription interface with all required fields (id?, name, frequency, times[], dose, halfLife, metaboliteLife?, peak, uptake)\n3. TimeSeriesPoint interface with time (hours) and concentration (0-1 normalized)\n4. GraphDataset interface with label, data[], and optional color\n\nInclude JSDoc comments documenting field purposes and units. Export all types.",
            "status": "pending",
            "testStrategy": "Create `src/core/models/__tests__/prescription.spec.ts` with type assertion tests: verify Prescription object with all required fields compiles, optional fields work correctly, FrequencyLabel only accepts valid values, TimeSeriesPoint concentration is typed as number.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create FREQUENCY_COUNTS Mapping and ValidationResult Interface",
            "description": "Add the frequency-to-count mapping constant and ValidationResult interface with valid, errors[], and warnings[] properties.",
            "dependencies": [
              1
            ],
            "details": "Add to prescription.ts:\n1. FREQUENCY_COUNTS constant: Record<FrequencyLabel, number | null> mapping each frequency to expected times count (once:1, bid:2, tid:3, qid:4, q6h:4, q8h:3, q12h:2, custom:null)\n2. ValidationResult interface: { valid: boolean; errors: string[]; warnings: string[] }\n3. Helper function isValidTimeFormat(time: string): boolean using regex /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/ for HH:MM validation\n\nExport the constant and interface for use in validation and form components.",
            "status": "pending",
            "testStrategy": "Test FREQUENCY_COUNTS mapping returns correct values for each frequency label. Test isValidTimeFormat accepts valid times ('09:00', '23:59', '00:00') and rejects invalid ('25:00', '12:60', 'invalid', '9:00' without leading zero edge case).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Field-Level Validation Rules",
            "description": "Implement validatePrescription function with individual field validations for name, dose, halfLife, peak, uptake, and metaboliteLife bounds.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement validatePrescription(rx: Prescription): ValidationResult with field-level checks:\n1. name: required, 1-100 characters, not empty/whitespace only\n2. dose: required, must be number in range 0.001-10000\n3. halfLife: required, must be number in range 0.1-240 hours\n4. peak: required, must be number in range 0.1-48 hours\n5. uptake: required, must be number in range 0.1-24 hours\n6. metaboliteLife: if provided, must be in range 0.1-1000 hours\n7. frequency: must be valid FrequencyLabel value\n\nReturn descriptive error messages indicating which field failed and why.",
            "status": "pending",
            "testStrategy": "Test valid prescription passes validation. Test each field boundary: name empty/101 chars fails, dose at 0/0.0009/10001 fails, halfLife at 0.09/241 fails, peak at 0.09/49 fails, uptake at 0.09/25 fails. Test metaboliteLife optional but validated when present. Test valid boundary values pass (dose=0.001, halfLife=0.1, etc).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Cross-Field Validation and Warnings",
            "description": "Add cross-field validation rules: times count must match frequency, all times must be valid HH:MM format, and warning (not error) when uptake >= halfLife.",
            "dependencies": [
              2,
              3
            ],
            "details": "Extend validatePrescription with cross-field checks:\n1. Times array validation: count must match FREQUENCY_COUNTS[frequency] (unless custom)\n2. Each time string must pass isValidTimeFormat regex (HH:MM 24-hour format)\n3. For 'custom' frequency: require at least 1 time entry\n4. Warning condition: if uptake >= halfLife, add warning about atypical absorption kinetics (not an error - still valid: true)\n5. Combine all errors and warnings into ValidationResult\n\nPreserve error messages from field-level validation, append cross-field errors.",
            "status": "pending",
            "testStrategy": "Test bid with 1 time fails, bid with 2 times passes. Test invalid time format '25:00' in array fails. Test custom frequency with 0 times fails, with 3 times passes. Test uptake < halfLife produces no warning. Test uptake = halfLife produces warning but valid:true. Test uptake > halfLife produces warning but valid:true. Integration test: valid prescription returns {valid:true, errors:[], warnings:[]}.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: (1) Define TypeScript interfaces for Prescription, TimeSeriesPoint, and GraphDataset with FrequencyLabel union type, (2) Create FREQUENCY_COUNTS constant mapping and ValidationResult interface, (3) Implement field-level validation rules (name, dose, halfLife, peak, uptake bounds), (4) Implement cross-field validation (times count matching frequency, HH:MM format, uptake>=halfLife warning). Each subtask should include corresponding test cases.",
        "updatedAt": "2026-02-14T04:18:22.250Z"
      },
      {
        "id": "3",
        "title": "Implement Single-Dose Pharmacokinetic Calculator",
        "description": "Create pure function for single-dose concentration calculation using one-compartment first-order absorption model. Include fallback formula for ka ≈ ke edge case.",
        "details": "1. Create `src/core/calculations/pkCalculator.ts`:\n   ```typescript\n   /**\n    * Calculate concentration at time t for a single dose\n    * C(t) = Dose × [ka/(ka - ke)] × (e^(-ke×t) - e^(-ka×t))\n    * Returns raw relative concentration (not normalized)\n    */\n   export function calculateConcentration(\n     time: number,\n     dose: number,\n     halfLife: number,\n     uptake: number\n   ): number {\n     const ke = 0.693 / halfLife;  // elimination rate constant\n     const ka = 0.693 / uptake;    // absorption rate constant\n\n     if (time <= 0) return 0;\n     if (dose === 0) return 0;\n\n     // Edge case: ka ≈ ke (absorption ≈ elimination)\n     if (Math.abs(ka - ke) < 0.001) {\n       // Fallback: C(t) ≈ Dose × ka × t × e^(-ke×t)\n       return dose * ka * time * Math.exp(-ke * time);\n     }\n\n     // Standard one-compartment formula\n     const ratio = ka / (ka - ke);\n     const elimTerm = Math.exp(-ke * time);\n     const absTerm = Math.exp(-ka * time);\n     return dose * ratio * (elimTerm - absTerm);\n   }\n   ```\n\n2. Add helper for computing peak time (Tmax):\n   ```typescript\n   export function calculatePeakTime(\n     halfLife: number,\n     uptake: number\n   ): number {\n     const ke = 0.693 / halfLife;\n     const ka = 0.693 / uptake;\n     if (Math.abs(ka - ke) < 0.001) return 1 / ke; // limit case\n     return Math.log(ka / ke) / (ka - ke);\n   }\n   ```\n\n3. Add helper for generating time series for single dose:\n   ```typescript\n   export function generateSingleDoseCurve(\n     dose: number,\n     halfLife: number,\n     uptake: number,\n     durationHours: number,\n     intervalMinutes: number = 15\n   ): TimeSeriesPoint[] {\n     const points: TimeSeriesPoint[] = [];\n     const steps = Math.ceil(durationHours * 60 / intervalMinutes);\n     for (let i = 0; i <= steps; i++) {\n       const time = i * intervalMinutes / 60;\n       const conc = calculateConcentration(time, dose, halfLife, uptake);\n       points.push({ time, concentration: Math.max(0, conc) });\n     }\n     return points;\n   }\n   ```",
        "testStrategy": "Create `src/core/calculations/__tests__/pkCalculator.spec.ts`:\n1. Test zero dose returns 0 concentration at all times\n2. Test negative time returns 0\n3. Test known-value reference case:\n   - dose=500, halfLife=6, uptake=1.5\n   - Verify peak occurs near expected Tmax\n   - Verify concentration at t=12h is ~25% of peak (one half-life after peak)\n4. Test ka ≈ ke fallback:\n   - uptake=6, halfLife=6 (ka=ke)\n   - Verify no NaN/Infinity in output\n   - Verify curve is reasonable shape\n5. Test extreme half-lives:\n   - Very short (0.1h): rapid decay\n   - Very long (240h): slow decay over days\n6. Test calculatePeakTime returns positive value\n7. Run `npm run test src/core/calculations/__tests__/pkCalculator.spec.ts`",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement core calculateConcentration function with standard one-compartment formula",
            "description": "Create the main calculateConcentration pure function in src/core/calculations/pkCalculator.ts implementing the one-compartment first-order absorption model: C(t) = Dose × [ka/(ka - ke)] × (e^(-ke×t) - e^(-ka×t)). Derive rate constants ka = 0.693/uptake and ke = 0.693/halfLife. Handle basic edge cases: return 0 for time ≤ 0 and dose = 0.",
            "dependencies": [],
            "details": "Create src/core/calculations/pkCalculator.ts with the calculateConcentration function. The function takes (time, dose, halfLife, uptake) parameters and returns raw relative concentration (not normalized). Implement: (1) Calculate ke = 0.693/halfLife (elimination rate constant), (2) Calculate ka = 0.693/uptake (absorption rate constant), (3) Guard clauses returning 0 for time ≤ 0 or dose === 0, (4) Standard formula: ratio = ka/(ka-ke), elimTerm = e^(-ke*t), absTerm = e^(-ka*t), return dose * ratio * (elimTerm - absTerm). Export the TimeSeriesPoint interface for use by other modules. This subtask does NOT include the ka≈ke fallback (handled in subtask 2).",
            "status": "pending",
            "testStrategy": "Create src/core/calculations/__tests__/pkCalculator.spec.ts with tests: (1) Zero dose returns 0 at all times, (2) Negative/zero time returns 0, (3) Reference case: dose=500, halfLife=6, uptake=1.5 - verify concentration at t=0 is 0, t=2h matches expected value ~280-320 (compute exact), t=12h shows decay, (4) Very short halfLife (0.5h) produces rapid decay, (5) Long halfLife (24h) shows slow decay, (6) Concentration is always non-negative for valid inputs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement ka≈ke fallback formula for numerical stability",
            "description": "Add the fallback formula C(t) ≈ Dose × ka × t × e^(-ke×t) to handle the edge case when absorption and elimination rate constants are nearly equal (|ka - ke| < 0.001), preventing division by near-zero in the standard formula.",
            "dependencies": [
              1
            ],
            "details": "Modify calculateConcentration to detect when |ka - ke| < 0.001 (threshold from CLAUDE.md spec). When detected, use the limit-case formula: return dose * ka * time * Math.exp(-ke * time). This is the mathematical limit of the standard formula as ka approaches ke, derived via L'Hôpital's rule. The 0.001 threshold balances numerical stability against accuracy - too large loses precision in normal cases, too small triggers floating-point instability. Place this check AFTER the zero guards but BEFORE the standard formula computation.",
            "status": "pending",
            "testStrategy": "Add tests to pkCalculator.spec.ts: (1) Exact ka=ke case: halfLife=6, uptake=6 - verify returns sensible curve, (2) Near-equal: halfLife=6, uptake=5.99 (ka-ke ≈ 0.00019) - should use fallback, verify smooth curve, (3) Just outside threshold: halfLife=6, uptake=5.5 - should use standard formula, (4) Compare fallback vs standard at boundary - curves should be nearly identical when |ka-ke| = 0.001, (5) Verify no division-by-zero errors when ka exactly equals ke.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement calculatePeakTime helper function with edge case handling",
            "description": "Create helper function to compute Tmax (time to peak concentration) using the formula t_max = ln(ka/ke) / (ka - ke), with proper handling for the ka≈ke edge case where Tmax approaches 1/ke.",
            "dependencies": [
              1
            ],
            "details": "Add calculatePeakTime(halfLife, uptake): number to pkCalculator.ts. Implementation: (1) Calculate ke = 0.693/halfLife and ka = 0.693/uptake, (2) If |ka - ke| < 0.001, return 1/ke (the limit as ka→ke), (3) Otherwise return Math.log(ka/ke) / (ka - ke). This function is useful for validation (comparing computed Tmax against user-entered peak value) and for finding the maximum concentration in a curve. Note: requires ka > 0 and ke > 0, which is guaranteed by validation rules (uptake and halfLife both have min 0.1).",
            "status": "pending",
            "testStrategy": "Add tests: (1) Reference case: halfLife=6, uptake=1.5 - verify Tmax ≈ 2.0-2.5 hours (compute exact: ln(4)/0.3465 ≈ 4.0h, verify formula), (2) Fast absorption: halfLife=6, uptake=0.5 - Tmax should be early (~0.8h), (3) Slow absorption: halfLife=6, uptake=4 - Tmax should be later (~4-5h), (4) ka≈ke edge case: halfLife=6, uptake=6 - should return 1/ke = 8.66h, (5) Verify Tmax is always positive for valid inputs, (6) Verify calculateConcentration at Tmax returns maximum concentration for the curve.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement generateSingleDoseCurve time-series generator with configurable interval",
            "description": "Create function to generate an array of TimeSeriesPoint objects representing the concentration curve over a specified duration, using configurable time-step intervals (default 15 minutes) for smooth chart rendering.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add generateSingleDoseCurve(dose, halfLife, uptake, durationHours, intervalMinutes = 15): TimeSeriesPoint[] to pkCalculator.ts. Implementation: (1) Calculate number of steps = Math.ceil(durationHours * 60 / intervalMinutes), (2) Loop from i=0 to steps inclusive, (3) For each step: time = i * intervalMinutes / 60, concentration = calculateConcentration(time, dose, halfLife, uptake), (4) Clamp concentration to Math.max(0, conc) to handle floating-point artifacts, (5) Push {time, concentration} to results array. Returns raw (unnormalized) concentrations - normalization happens at the multi-dose accumulation level. The 15-min default provides 4 points/hour which is sufficient for smooth Chart.js rendering.",
            "status": "pending",
            "testStrategy": "Add tests: (1) Verify correct number of points: duration=24h, interval=15min → 97 points (0 to 96 inclusive), (2) Verify first point is {time: 0, concentration: 0}, (3) Reference case: dose=500, halfLife=6, uptake=1.5, duration=24h - verify curve shape: rises to peak around Tmax, then decays, (4) Custom interval: interval=30min halves point count, (5) All concentrations are ≥ 0, (6) Curve matches individual calculateConcentration calls at sampled times, (7) Short duration (1h) works correctly, (8) Long duration (168h/1week) generates reasonable point count without performance issues.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: (1) Implement core calculateConcentration function with standard one-compartment formula C(t) = Dose × [ka/(ka - ke)] × (e^(-ke×t) - e^(-ka×t)), (2) Implement ka≈ke fallback formula using limit case C(t) ≈ Dose × ka × t × e^(-ke×t), (3) Implement calculatePeakTime helper function with edge case handling, (4) Implement generateSingleDoseCurve time-series generator with configurable interval. Include comprehensive tests with known pharmacological reference values for each subtask.",
        "updatedAt": "2026-02-14T04:39:57.484Z"
      },
      {
        "id": "4",
        "title": "Implement Multi-Dose Accumulation Calculator",
        "description": "Create function to calculate concentration curves for repeated dosing schedules, summing contributions from each dose and normalizing the final curve to peak=1.0.",
        "details": "1. Add to `src/core/calculations/pkCalculator.ts` or create `src/core/calculations/multiDoseProfile.ts`:\n   ```typescript\n   import { Prescription, TimeSeriesPoint } from '../models/prescription';\n   import { calculateConcentration } from './pkCalculator';\n\n   /**\n    * Convert HH:MM time string to hours from midnight\n    */\n   function timeStringToHours(time: string): number {\n     const [hours, minutes] = time.split(':').map(Number);\n     return hours + minutes / 60;\n   }\n\n   /**\n    * Generate dose times in hours for a multi-day simulation\n    * @param times - Array of HH:MM strings\n    * @param numDays - Number of days to simulate\n    * @returns Array of dose times in hours from start\n    */\n   function expandDoseTimes(\n     times: string[],\n     numDays: number\n   ): number[] {\n     const doseTimes: number[] = [];\n     for (let day = 0; day < numDays; day++) {\n       for (const t of times) {\n         doseTimes.push(day * 24 + timeStringToHours(t));\n       }\n     }\n     return doseTimes.sort((a, b) => a - b);\n   }\n\n   /**\n    * Calculate accumulated concentration over time from repeated doses\n    * Sums contributions from each dose, then normalizes to peak=1.0\n    */\n   export function accumulateDoses(\n     prescription: Prescription,\n     startHours: number,\n     endHours: number,\n     intervalMinutes: number = 15\n   ): TimeSeriesPoint[] {\n     const numDays = Math.ceil(endHours / 24) + 1;\n     const doseTimes = expandDoseTimes(prescription.times, numDays);\n\n     const points: TimeSeriesPoint[] = [];\n     const steps = Math.ceil((endHours - startHours) * 60 / intervalMinutes);\n     let maxConc = 0;\n\n     for (let i = 0; i <= steps; i++) {\n       const time = startHours + i * intervalMinutes / 60;\n       let totalConc = 0;\n\n       for (const doseTime of doseTimes) {\n         if (doseTime <= time) {\n           const elapsed = time - doseTime;\n           totalConc += calculateConcentration(\n             elapsed,\n             prescription.dose,\n             prescription.halfLife,\n             prescription.uptake\n           );\n         }\n       }\n\n       points.push({ time, concentration: Math.max(0, totalConc) });\n       maxConc = Math.max(maxConc, totalConc);\n     }\n\n     // Normalize to peak = 1.0\n     if (maxConc > 0) {\n       for (const p of points) {\n         p.concentration /= maxConc;\n       }\n     }\n\n     return points;\n   }\n   ```\n\n2. Add chart data formatting:\n   ```typescript\n   import { GraphDataset } from '../models/prescription';\n\n   export function getGraphData(\n     prescriptions: Prescription[],\n     startHours: number,\n     endHours: number\n   ): GraphDataset[] {\n     const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6'];\n     return prescriptions.map((rx, i) => ({\n       label: `${rx.name} (${rx.frequency})`,\n       data: accumulateDoses(rx, startHours, endHours),\n       color: colors[i % colors.length]\n     }));\n   }\n   ```",
        "testStrategy": "Create `src/core/calculations/__tests__/multiDoseProfile.spec.ts`:\n1. Test single dose (once): curve matches generateSingleDoseCurve\n2. Test bid (twice daily): verify 2 peaks per day, second peak higher due to accumulation\n3. Test steady-state: after 5 half-lives, peak-to-trough ratio converges\n4. Test normalization: max concentration is exactly 1.0\n5. Test empty times array: returns flat zero curve\n6. Test time expansion: verify expandDoseTimes produces correct hours\n7. Test getGraphData: verify output format matches GraphDataset\n8. Reference case: bid with halfLife=6, verify accumulation factor ~1.5-2x by day 3\n9. Run `npm run test src/core/calculations/__tests__/multiDoseProfile.spec.ts`",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement timeStringToHours helper function",
            "description": "Create a utility function to convert HH:MM time strings (24-hour format) into decimal hours for use in pharmacokinetic calculations.",
            "dependencies": [],
            "details": "Add timeStringToHours function to src/core/calculations/multiDoseProfile.ts. Function should: (1) Parse HH:MM string format using split(':'), (2) Convert to Number and calculate hours + minutes/60, (3) Handle edge cases: midnight '00:00' → 0, '23:59' → 23.983, invalid formats. Export function for testing. Example: '09:30' → 9.5, '21:00' → 21.0. Include input validation to handle malformed strings gracefully (throw descriptive error for invalid format).",
            "status": "pending",
            "testStrategy": "Create src/core/calculations/__tests__/multiDoseProfile.spec.ts with tests: (1) '00:00' → 0, (2) '12:00' → 12, (3) '23:59' → 23.983..., (4) '09:30' → 9.5, (5) '14:45' → 14.75, (6) invalid format throws error, (7) empty string throws error.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement expandDoseTimes function for multi-day scheduling",
            "description": "Create function to generate an array of dose timestamps (in hours from simulation start) across multiple days based on the prescription's daily dosing times.",
            "dependencies": [
              1
            ],
            "details": "Add expandDoseTimes function to src/core/calculations/multiDoseProfile.ts. Takes times array (HH:MM strings) and numDays parameter. For each day 0 to numDays-1, iterate through times array and compute: day * 24 + timeStringToHours(time). Return sorted array of dose times in ascending order. Example: times=['09:00', '21:00'], numDays=3 → [9, 21, 33, 45, 57, 69]. Handle edge case where numDays=0 returns empty array. This enables accumulation calculation to know when each dose was administered.",
            "status": "pending",
            "testStrategy": "Tests in multiDoseProfile.spec.ts: (1) Single dose once daily for 3 days → [time, time+24, time+48], (2) BID schedule for 2 days → 4 dose times, (3) TID schedule for 1 day → 3 dose times, (4) numDays=0 → empty array, (5) Verify sorted output regardless of input time order, (6) Test day boundary handling with late-night doses (e.g., '23:00').",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement accumulateDoses core accumulation function",
            "description": "Create the main accumulation function that calculates total concentration at each time point by summing contributions from all doses administered up to that point.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add accumulateDoses function to multiDoseProfile.ts. Takes Prescription, startHours, endHours, and optional intervalMinutes (default 15). Implementation: (1) Calculate numDays = ceil(endHours/24)+1, (2) Get all dose times via expandDoseTimes, (3) Generate time steps from startHours to endHours at interval, (4) For each time step, sum calculateConcentration(elapsed, dose, halfLife, uptake) for all doses where doseTime <= currentTime (elapsed = currentTime - doseTime), (5) Store raw concentration (may exceed 1.0 due to accumulation), (6) Clamp negative values to 0. Return TimeSeriesPoint[] with raw (unnormalized) concentrations initially.",
            "status": "pending",
            "testStrategy": "Tests: (1) Single dose 'once' matches single-dose curve shape, (2) BID dosing shows two peaks per day with second peak higher than first due to residual, (3) Zero dose returns all-zero concentrations, (4) Verify O(n*m) complexity handles 7-day simulation with q6h dosing efficiently (<100ms), (5) Test with known reference case from CLAUDE.md (dose=500, halfLife=6, uptake=1.5), (6) Verify negative clamping works.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add normalization logic to scale accumulated curve to peak=1.0",
            "description": "Extend accumulateDoses to normalize the final concentration curve so that the maximum concentration point equals 1.0, maintaining relative concentration ratios.",
            "dependencies": [
              3
            ],
            "details": "After accumulating all dose contributions in accumulateDoses: (1) Track maxConc during accumulation loop (max of all totalConc values), (2) After loop completes, if maxConc > 0, divide all point concentrations by maxConc, (3) This ensures output is normalized TimeSeriesPoint[] with concentration values in 0-1 range, (4) Handle edge case where maxConc=0 (zero dose or no doses yet) by leaving concentrations as 0. The normalization preserves peak-to-trough ratios while enabling consistent Y-axis scaling across different drugs.",
            "status": "pending",
            "testStrategy": "Tests: (1) Verify max concentration in output is exactly 1.0, (2) All concentrations are in [0, 1] range, (3) Peak-to-trough ratio preserved after normalization (compare raw vs normalized), (4) Zero dose case doesn't cause division-by-zero, (5) Steady-state convergence test: simulate 5+ half-lives of BID dosing, verify final peak-to-trough ratio matches theoretical R = 1/(1-e^(-ke*tau)) within 5%, (6) Accumulation factor test: verify first dose peak < steady-state peak ratio matches expected accumulation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement getGraphData function for chart formatting",
            "description": "Create function to transform multiple prescriptions into GraphDataset array with assigned colors, ready for Chart.js rendering.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add getGraphData function to multiDoseProfile.ts. Takes prescriptions array, startHours, and endHours. For each prescription: (1) Call accumulateDoses to get normalized TimeSeriesPoint[], (2) Create GraphDataset with label = 'name (frequency)', data = TimeSeriesPoint[], color from predefined palette. Color palette: ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6'] cycling via index % 5. Export GraphDataset type from models if not already. This function is the primary interface for GraphViewer component to obtain chart-ready data.",
            "status": "pending",
            "testStrategy": "Tests: (1) Empty prescriptions array returns empty datasets, (2) Single prescription returns one dataset with correct label format, (3) Multiple prescriptions return datasets with different colors, (4) Colors cycle when >5 prescriptions, (5) Dataset data array has expected length based on time range and interval, (6) Integration test: pass through to accumulateDoses correctly propagates all prescription parameters.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: (1) Implement timeStringToHours helper to convert HH:MM strings to decimal hours, (2) Implement expandDoseTimes function to generate dose timestamps across multiple days, (3) Implement accumulateDoses core function that sums contributions from all doses at each time point, (4) Implement normalization logic to scale curve to peak=1.0, (5) Implement getGraphData function to format multiple prescriptions into GraphDataset array with colors. Include steady-state convergence tests and accumulation factor verification.",
        "updatedAt": "2026-02-14T14:07:06.510Z"
      },
      {
        "id": "5",
        "title": "Implement localStorage Prescription Storage",
        "description": "Create storage layer for persisting prescriptions to browser localStorage with CRUD operations and unique ID generation.",
        "details": "1. Create `src/core/storage/prescriptionStorage.ts`:\n   ```typescript\n   import { Prescription } from '../models/prescription';\n\n   const STORAGE_KEY = 'pk-grapher-prescriptions';\n\n   /**\n    * Generate unique ID for prescriptions\n    */\n   function generateId(): string {\n     return `rx-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n   }\n\n   /**\n    * Get all saved prescriptions\n    */\n   export function getAllPrescriptions(): Prescription[] {\n     const data = localStorage.getItem(STORAGE_KEY);\n     if (!data) return [];\n     try {\n       return JSON.parse(data) as Prescription[];\n     } catch {\n       console.error('Failed to parse prescriptions');\n       return [];\n     }\n   }\n\n   /**\n    * Get prescription by ID\n    */\n   export function getPrescription(id: string): Prescription | undefined {\n     return getAllPrescriptions().find(rx => rx.id === id);\n   }\n\n   /**\n    * Save a new prescription (assigns ID)\n    */\n   export function savePrescription(rx: Prescription): Prescription {\n     const prescriptions = getAllPrescriptions();\n     const newRx = { ...rx, id: generateId() };\n     prescriptions.push(newRx);\n     localStorage.setItem(STORAGE_KEY, JSON.stringify(prescriptions));\n     return newRx;\n   }\n\n   /**\n    * Update existing prescription\n    */\n   export function updatePrescription(rx: Prescription): boolean {\n     if (!rx.id) return false;\n     const prescriptions = getAllPrescriptions();\n     const index = prescriptions.findIndex(p => p.id === rx.id);\n     if (index === -1) return false;\n     prescriptions[index] = rx;\n     localStorage.setItem(STORAGE_KEY, JSON.stringify(prescriptions));\n     return true;\n   }\n\n   /**\n    * Delete prescription by ID\n    */\n   export function deletePrescription(id: string): boolean {\n     const prescriptions = getAllPrescriptions();\n     const filtered = prescriptions.filter(rx => rx.id !== id);\n     if (filtered.length === prescriptions.length) return false;\n     localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));\n     return true;\n   }\n\n   /**\n    * Duplicate prescription (creates new with copy of data)\n    */\n   export function duplicatePrescription(id: string): Prescription | undefined {\n     const original = getPrescription(id);\n     if (!original) return undefined;\n     const { id: _, ...data } = original;\n     return savePrescription({ ...data, name: `${data.name} (copy)` });\n   }\n   ```\n\n2. Add storage utility functions:\n   ```typescript\n   export function clearAllPrescriptions(): void {\n     localStorage.removeItem(STORAGE_KEY);\n   }\n\n   export function getStorageUsage(): { used: number; available: number } {\n     const data = localStorage.getItem(STORAGE_KEY) || '';\n     return { used: data.length * 2, available: 5 * 1024 * 1024 }; // ~5MB\n   }\n   ```",
        "testStrategy": "Create `src/core/storage/__tests__/prescriptionStorage.spec.ts`:\n1. Test savePrescription assigns unique ID\n2. Test getAllPrescriptions returns empty array initially\n3. Test save then retrieve: data matches\n4. Test updatePrescription modifies existing\n5. Test deletePrescription removes item\n6. Test duplicatePrescription creates copy with new ID\n7. Test corrupted localStorage gracefully returns empty\n8. Test multiple prescriptions persist correctly\n9. Mock localStorage for isolation:\n   ```typescript\n   beforeEach(() => {\n     localStorage.clear();\n   });\n   ```\n10. Run `npm run test src/core/storage/__tests__/prescriptionStorage.spec.ts`",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create prescriptionStorage.ts with generateId function",
            "description": "Create the storage module file and implement the unique ID generator function using timestamp and random string.",
            "dependencies": [],
            "details": "Create `src/core/storage/prescriptionStorage.ts`. Define STORAGE_KEY constant as 'pk-grapher-prescriptions'. Implement generateId() that returns `rx-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` for unique prescription identifiers.",
            "status": "pending",
            "testStrategy": "Test generateId() returns string matching pattern rx-{timestamp}-{random9chars}. Test multiple calls return unique IDs. Test ID uniqueness over 1000 rapid calls.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement getAllPrescriptions and getPrescription functions",
            "description": "Create read operations for retrieving all prescriptions from localStorage and finding a single prescription by ID.",
            "dependencies": [
              1
            ],
            "details": "Implement getAllPrescriptions() that reads STORAGE_KEY from localStorage, parses JSON, and returns Prescription[] or empty array. Add try-catch for corrupted data recovery. Implement getPrescription(id) that filters by ID and returns matching prescription or undefined.",
            "status": "pending",
            "testStrategy": "Test returns empty array when localStorage empty. Test returns parsed array when data exists. Test corrupted JSON returns empty array with console.error. Test getPrescription finds existing ID. Test getPrescription returns undefined for missing ID.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement savePrescription and updatePrescription functions",
            "description": "Create write operations for adding new prescriptions and modifying existing ones in localStorage.",
            "dependencies": [
              2
            ],
            "details": "Implement savePrescription(rx) that assigns new ID via generateId(), appends to existing prescriptions array, saves to localStorage, and returns the new prescription with ID. Implement updatePrescription(rx) that finds prescription by ID, replaces it in array, saves, and returns boolean success status.",
            "status": "pending",
            "testStrategy": "Test savePrescription assigns unique ID to prescription. Test saved prescription can be retrieved. Test updatePrescription modifies existing data. Test updatePrescription returns false for non-existent ID. Test updatePrescription returns false when rx.id is undefined.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement deletePrescription and duplicatePrescription functions",
            "description": "Create delete operation and prescription duplication with automatic naming.",
            "dependencies": [
              3
            ],
            "details": "Implement deletePrescription(id) that filters out matching ID, saves remaining array, returns boolean success. Implement duplicatePrescription(id) that gets original prescription, creates copy without ID, appends ' (copy)' to name, saves as new prescription via savePrescription(), and returns the duplicate or undefined if original not found.",
            "status": "pending",
            "testStrategy": "Test deletePrescription removes existing prescription. Test deletePrescription returns false for non-existent ID. Test duplicatePrescription creates new prescription with different ID. Test duplicate has ' (copy)' suffix in name. Test duplicatePrescription returns undefined for missing ID.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add utility functions and export module",
            "description": "Implement clearAllPrescriptions, getStorageUsage utilities and ensure all functions are properly exported.",
            "dependencies": [
              4
            ],
            "details": "Implement clearAllPrescriptions() that removes STORAGE_KEY from localStorage. Implement getStorageUsage() returning { used: number, available: number } where used is data.length * 2 bytes and available is ~5MB estimate. Export all public functions. Import Prescription type from '../models/prescription'.",
            "status": "pending",
            "testStrategy": "Test clearAllPrescriptions removes all data. Test getStorageUsage returns correct byte count for stored data. Test getStorageUsage returns 0 used when empty. Test all CRUD functions work together in integration test: save, retrieve, update, duplicate, delete, clear.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed. The task is already well-scoped with clear CRUD operations and the implementation is straightforward localStorage wrapper code.",
        "updatedAt": "2026-02-14T14:14:05.440Z"
      },
      {
        "id": "6",
        "title": "Implement Prescription Input Form Component",
        "description": "Create Vue 3 component with reactive form for prescription input, including frequency selector, time pickers, numeric inputs with validation, and real-time error display.",
        "details": "1. Create `src/components/PrescriptionForm.vue`:\n   ```vue\n   <script setup lang=\"ts\">\n   import { ref, computed, watch } from 'vue';\n   import type { Prescription, FrequencyLabel } from '@/core/models/prescription';\n   import { validatePrescription, FREQUENCY_COUNTS } from '@/core/models/prescription';\n\n   const emit = defineEmits<{\n     submit: [prescription: Prescription]\n   }>();\n\n   const props = defineProps<{\n     initial?: Prescription\n   }>();\n\n   // Form state\n   const name = ref(props.initial?.name || '');\n   const frequency = ref<FrequencyLabel>(props.initial?.frequency || 'bid');\n   const times = ref<string[]>(props.initial?.times || ['09:00', '21:00']);\n   const dose = ref<number>(props.initial?.dose || 500);\n   const halfLife = ref<number>(props.initial?.halfLife || 6);\n   const peak = ref<number>(props.initial?.peak || 2);\n   const uptake = ref<number>(props.initial?.uptake || 1);\n\n   // Adjust times array when frequency changes\n   watch(frequency, (newFreq) => {\n     const count = FREQUENCY_COUNTS[newFreq];\n     if (count === null) return; // custom\n     while (times.value.length < count) times.value.push('12:00');\n     while (times.value.length > count) times.value.pop();\n   });\n\n   const prescription = computed<Prescription>(() => ({\n     name: name.value,\n     frequency: frequency.value,\n     times: times.value,\n     dose: dose.value,\n     halfLife: halfLife.value,\n     peak: peak.value,\n     uptake: uptake.value\n   }));\n\n   const validation = computed(() => validatePrescription(prescription.value));\n   const canSubmit = computed(() => validation.value.valid);\n\n   function handleSubmit() {\n     if (canSubmit.value) {\n       emit('submit', prescription.value);\n     }\n   }\n   </script>\n\n   <template>\n     <form @submit.prevent=\"handleSubmit\" class=\"prescription-form\">\n       <!-- Drug Name -->\n       <div class=\"field\">\n         <label for=\"name\">Drug Name</label>\n         <input id=\"name\" v-model=\"name\" type=\"text\" required />\n       </div>\n\n       <!-- Frequency -->\n       <div class=\"field\">\n         <label for=\"frequency\">Dosing Frequency</label>\n         <select id=\"frequency\" v-model=\"frequency\">\n           <option value=\"once\">Once daily</option>\n           <option value=\"bid\">BID (twice daily)</option>\n           <option value=\"tid\">TID (three times daily)</option>\n           <option value=\"qid\">QID (four times daily)</option>\n           <option value=\"q6h\">Every 6 hours</option>\n           <option value=\"q8h\">Every 8 hours</option>\n           <option value=\"q12h\">Every 12 hours</option>\n           <option value=\"custom\">Custom</option>\n         </select>\n       </div>\n\n       <!-- Times -->\n       <div class=\"field\">\n         <label>Dosing Times</label>\n         <div v-for=\"(_, i) in times\" :key=\"i\">\n           <input v-model=\"times[i]\" type=\"time\" />\n         </div>\n       </div>\n\n       <!-- Numeric inputs for dose, halfLife, peak, uptake -->\n       <!-- ... similar pattern -->\n\n       <!-- Errors -->\n       <ul v-if=\"validation.errors.length\" class=\"errors\">\n         <li v-for=\"err in validation.errors\" :key=\"err\">{{ err }}</li>\n       </ul>\n\n       <!-- Warnings -->\n       <ul v-if=\"validation.warnings.length\" class=\"warnings\">\n         <li v-for=\"warn in validation.warnings\" :key=\"warn\">{{ warn }}</li>\n       </ul>\n\n       <button type=\"submit\" :disabled=\"!canSubmit\">Generate Graph</button>\n     </form>\n   </template>\n   ```\n\n2. Add styling for form layout, error/warning display\n3. Include educational disclaimer text above form\n<info added on 2026-02-14T14:25:22.318Z>\nBased on my analysis of the codebase, I can now generate the task update. The plan files exist and Task 2 (prescription models) is marked as done, so the dependency is satisfied.\n\n---\n\nPlan and Validation Links (Generated 2026-02-13/14)\n\nImplementation Plan (persistent, committed to git):\n- thoughts/shared/plans/task-6-prescription-input-form.md - Detailed 4-phase implementation plan with complete reference code and test strategy\n\nImplementation Reference:\n- thoughts/shared/plans/prescription-form-implementation.md - Additional implementation guide\n\nPlan Cache (temporary):\n- .claude/cache/agents/plan-agent/output-20260214-prescription-form.md - Agent workspace copy\n\nValidation Report (temporary):\n- .claude/cache/agents/validate-agent/output-2026-02-13-validation-task-6.md - Comprehensive validation against best practices\n\nStatus: Plan created, validated, and integrated. Ready for implementation.\n\nBlocking Dependency:\n- Task 2 (Prescription Data Models and Validation) - DONE. Provides Prescription, FrequencyLabel, ValidationResult types; FREQUENCY_MAP, VALIDATION_RULES, validatePrescription() exports from src/core/models/prescription.ts\n\nKey Implementation Notes:\n- Import from @/core/models/prescription (path alias configured in tsconfig.app.json)\n- Use FREQUENCY_MAP (not FREQUENCY_COUNTS as originally specified in task details) for mapping frequency labels to time counts\n- validatePrescription() returns { valid: boolean, errors: string[], warnings: string[] }\n- Test fixtures available in src/core/models/__tests__/fixtures.ts (SINGLE_DOSE_FIXTURE, BID_MULTI_DOSE_FIXTURE, IBUPROFEN_FIXTURE)\n\nFiles to Create:\n- src/components/PrescriptionForm.vue - Main form component\n- src/components/__tests__/PrescriptionForm.spec.ts - Component test suite (~35-40 tests)\n\nEstimated Effort (after dependencies): 2.5-3 hours total\n- Phase 1 (form structure): 30-45 minutes\n- Phase 2 (times reactivity): 20-30 minutes\n- Phase 3 (validation wiring): 20-30 minutes\n- Phase 4 (styling + disclaimer): 30-45 minutes\n- Test suite: 45-60 minutes\n</info added on 2026-02-14T14:25:22.318Z>",
        "testStrategy": "Create `src/components/__tests__/PrescriptionForm.spec.ts`:\n1. Test form renders all inputs\n2. Test frequency change adjusts times array length\n3. Test validation errors display in UI\n4. Test valid form enables submit button\n5. Test submit emits prescription data\n6. Test invalid form disables submit button\n7. Test initial prop populates form fields\n8. Test time input accepts HH:MM format\n9. Use Vue Test Utils:\n   ```typescript\n   import { mount } from '@vue/test-utils';\n   import PrescriptionForm from '../PrescriptionForm.vue';\n   ```\n10. Run `npm run test src/components/__tests__/PrescriptionForm.spec.ts`",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Form Structure with All Input Fields",
            "description": "Build the core PrescriptionForm.vue component structure with all required input fields: drug name (text), frequency (select dropdown with bid/tid/qid/q6h/q8h/q12h/once/custom options), dose/halfLife/peak/uptake (number inputs), and time inputs array.",
            "dependencies": [],
            "details": "Create src/components/PrescriptionForm.vue with Vue 3 Composition API using <script setup lang=\"ts\">. Define reactive refs for each form field: name (string), frequency (FrequencyLabel), times (string[]), dose/halfLife/peak/uptake (numbers). Import types from @/core/models/prescription. Set up basic template with labeled inputs: text input for name, select for frequency with all 8 options (once through custom), number inputs with min/max/step attributes matching VALIDATION_RULES (dose: 0.001-10000, halfLife: 0.1-240, peak: 0.1-48, uptake: 0.1-24). Use native HTML5 time inputs for dosing times. Add proper 'for' attributes on labels matching input 'id' attributes for accessibility. Include defineEmits for 'submit' event that passes Prescription object, and defineProps for optional 'initial' Prescription (edit mode). Test: render form, verify all 8 inputs present, verify frequency dropdown has all options, verify number inputs have correct min/max constraints.",
            "status": "pending",
            "testStrategy": "Create src/components/__tests__/PrescriptionForm.spec.ts using Vue Test Utils. Test 1: mount component, verify all input fields render (name, frequency, dose, halfLife, peak, uptake, at least one time input). Test 2: verify frequency select has all 8 options. Test 3: verify number inputs have proper min/max attributes. Test 4: verify initial prop populates form fields when provided.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Reactive Times Array with Frequency Watch",
            "description": "Add Vue watch effect to dynamically adjust the times array length when frequency selection changes, ensuring the array size matches FREQUENCY_COUNTS mapping (bid=2, tid=3, qid=4, etc.).",
            "dependencies": [
              1
            ],
            "details": "Import FREQUENCY_COUNTS from @/core/models/prescription (maps frequency labels to required times count: once=1, bid=2, tid=3, qid=4, q6h=4, q8h=3, q12h=2, custom=null). Use Vue watch() on frequency ref with callback that: 1) Gets required count from FREQUENCY_COUNTS[newFreq], 2) If count is null (custom), allow user to manually add/remove times, 3) If times.length < count, push default times ('12:00') until array reaches required length, 4) If times.length > count, pop from end until array reaches required length. Initialize times array based on initial frequency (default to ['09:00', '21:00'] for bid). In template, use v-for to render time inputs dynamically based on times array length. For custom frequency, add +/- buttons to allow adding/removing time slots manually. Ensure time inputs use type='time' for native HH:MM picker support.",
            "status": "pending",
            "testStrategy": "Test 1: Change frequency from 'bid' to 'tid', verify times array grows to 3 elements. Test 2: Change from 'qid' to 'once', verify times array shrinks to 1 element. Test 3: Verify 'custom' frequency allows manual add/remove of time slots. Test 4: Verify initial times from props are preserved when frequency matches. Test 5: Verify time inputs render correct count for each frequency option.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Wire Validation and Display Errors/Warnings Conditionally",
            "description": "Connect the validatePrescription function to a computed property that runs on every form change, and conditionally display validation errors and warnings in the UI with proper styling.",
            "dependencies": [
              1
            ],
            "details": "Import validatePrescription from @/core/models/prescription. Create computed property 'prescription' that builds Prescription object from all form refs. Create computed property 'validation' that calls validatePrescription(prescription.value) returning { valid: boolean, errors: string[], warnings: string[] }. Create computed 'canSubmit' = validation.value.valid. In template: render errors as <ul class='errors'> with v-if='validation.errors.length', render warnings as <ul class='warnings'> with v-if='validation.warnings.length'. Each list item shows the error/warning message. Add :disabled='!canSubmit' to submit button. Implement handleSubmit() that only emits 'submit' event with prescription when canSubmit is true. Errors should appear in red/danger color, warnings in yellow/amber. Ensure validation runs reactively on any field change (automatic via computed dependency tracking).",
            "status": "pending",
            "testStrategy": "Test 1: Leave name empty, verify error message appears. Test 2: Set dose to 0, verify dose validation error. Test 3: Set uptake >= halfLife, verify warning appears (not error). Test 4: Fill all fields validly, verify no errors shown and submit button enabled. Test 5: Click submit with valid form, verify 'submit' event emitted with prescription data. Test 6: Click submit with invalid form, verify no event emitted.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Form Styling and Educational Disclaimer",
            "description": "Apply CSS styling for form layout, input fields, error/warning display, and add the required educational disclaimer text with proper accessibility labels throughout.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add <style scoped> section with form styling: .prescription-form uses flexbox/grid for responsive layout, .field class for label+input pairs with consistent spacing, inputs have readable font size and padding. Style .errors with red background/border and error icon, .warnings with yellow/amber background and warning icon. Disabled submit button should appear greyed out. Add educational disclaimer above form: \"This tool is for visualization and educational purposes only. Not for medical dosing decisions. Actual drug levels vary by individual.\" Style disclaimer with distinct background and icon (⚠️). Ensure all form controls have proper accessibility: labels with 'for' attribute, required fields marked with aria-required='true', error messages linked via aria-describedby, fieldsets/legends for grouped controls (like times array). Add helpful hint text below numeric inputs showing valid ranges (e.g., 'Half-life: 0.1-240 hours'). Ensure color contrast meets WCAG AA standards.",
            "status": "pending",
            "testStrategy": "Test 1: Verify disclaimer text renders above form. Test 2: Verify error messages have role='alert' or aria-live for screen readers. Test 3: Verify all inputs have associated labels (accessibility audit). Test 4: Visual inspection of responsive layout at different viewport sizes. Test 5: Verify disabled submit button has appropriate styling and aria-disabled state.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: (1) Create form structure with all input fields (name, frequency dropdown, dose/halfLife/peak/uptake number inputs), (2) Implement reactive times array with dynamic length based on frequency selection using Vue watch, (3) Wire validation to computed property and display errors/warnings conditionally, (4) Add form styling and educational disclaimer text with proper accessibility labels. Include Vue Test Utils component tests for each subtask.",
        "updatedAt": "2026-02-14T15:03:09.692Z"
      },
      {
        "id": "7",
        "title": "Implement Graph Visualization Component",
        "description": "Create Vue 3 component using Chart.js to render pharmacokinetic concentration curves with proper axis labels, legend, and multi-drug overlay support.",
        "status": "done",
        "dependencies": [
          "1",
          "4"
        ],
        "priority": "high",
        "details": "Implementation plan available at `thoughts/shared/plans/task-7-graph-viewer.md`.\n\n**Target file:** `src/components/GraphViewer.vue`\n\n**Dependencies verified:**\n- Chart.js 4.5.1 installed (package.json:19)\n- `GraphDataset` and `TimeSeriesPoint` types defined in `src/core/models/prescription.ts:25-36`\n- Uses same component pattern as existing `src/components/PrescriptionForm.vue`\n\n**Key implementation details:**\n\n1. **Props interface:**\n   - `datasets: GraphDataset[]` (required) - Array of `{ label, data: TimeSeriesPoint[], color? }`\n   - `startHours?: number` (default: 0) - X-axis minimum\n   - `endHours?: number` (default: 48) - X-axis maximum\n\n2. **Chart.js configuration:**\n   - Type: 'line' with linear x/y scales\n   - X-axis: 'Time (hours)' from startHours to endHours\n   - Y-axis: 'Relative Concentration (0-1)' fixed 0 to 1\n   - 8-color palette for multi-drug overlay: `['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16']`\n   - Line styling: tension=0.1 (minimal smoothing per CLAUDE.md), pointRadius=0, borderWidth=2\n   - Tooltip: mode='index', shows time and concentration values\n\n3. **Lifecycle management:**\n   - `chartInstance` stored as plain `let` (NOT reactive ref - Vue proxy interferes with Chart.js)\n   - `onMounted`: Call `renderChart()`\n   - Combined `watch` on `[datasets, startHours, endHours]` with `{ deep: true }`: Call `renderChart()`\n   - `onUnmounted`: Call `chartInstance?.destroy()` to prevent memory leaks\n   - `renderChart()`: Destroy existing instance before creating new one\n\n4. **Template structure:**\n   - Wrapper `div.graph-viewer`\n   - Educational disclaimer banner (yellow background, warning styling)\n   - `div.chart-container` with position:relative, height:400px\n   - Canvas element with template ref\n\n5. **Edge cases:**\n   - Empty datasets: Destroy chart, leave canvas blank (no error)\n   - Single data point: Handle gracefully\n   - >8 datasets: Color palette wraps with modulo",
        "testStrategy": "**Test file:** `src/components/__tests__/GraphViewer.spec.ts`\n\n**Test approach:** Mock Chart.js module (jsdom lacks Canvas API). Follow test patterns from `src/components/__tests__/PrescriptionForm.spec.ts`.\n\n**Mock setup:**\n```typescript\nconst mockDestroy = vi.fn()\nconst mockChartInstance = { destroy: mockDestroy }\nconst MockChart = vi.fn(() => mockChartInstance) as Mock & { register: Mock }\nMockChart.register = vi.fn()\n\nvi.mock('chart.js', () => ({\n  Chart: MockChart,\n  registerables: [],\n}))\n```\n\n**Test cases (~20 tests across 4 categories):**\n\n1. **Component structure:**\n   - Renders canvas element\n   - Renders educational disclaimer with correct text\n   - Renders chart-container div\n\n2. **Chart creation:**\n   - Registers Chart.js modules on import\n   - Does NOT create Chart when datasets empty\n   - Creates Chart when datasets provided\n   - Passes canvas element to Chart constructor\n   - Configures 'line' chart type\n   - Uses default startHours=0, endHours=48 when props omitted\n   - Uses provided startHours/endHours props\n   - Fixes y-axis range to 0-1\n   - Maps TimeSeriesPoint to Chart.js {x, y} format\n   - Uses dataset color when provided\n   - Assigns default palette colors when color not provided\n   - Renders multiple datasets for multi-drug overlay\n\n3. **Lifecycle management:**\n   - Destroys chart instance on unmount\n   - Destroys and recreates chart when datasets change\n   - Re-renders when endHours changes\n   - Does NOT call destroy when unmounting with empty datasets\n\n4. **Edge cases:**\n   - Handles transition from datasets to empty datasets\n   - Handles single data point in dataset\n   - Wraps color palette for >8 datasets\n\n**Commands:**\n```bash\nnpm run test:unit -- src/components/__tests__/GraphViewer.spec.ts\nnpm run type-check\nnpm run lint\n```",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Chart.js Canvas with Vue Ref and Module Registration",
            "description": "Create the GraphViewer.vue component structure with Chart.js imports, canvas element with Vue ref binding, and register all required Chart.js modules for line chart rendering.",
            "dependencies": [],
            "details": "**File to create:** `src/components/GraphViewer.vue`\n\n**Implementation steps:**\n\n1. Create component with `<script setup lang=\"ts\">` (matching PrescriptionForm.vue pattern)\n\n2. Import and register Chart.js:\n   ```typescript\n   import { Chart, registerables } from 'chart.js'\n   import type { GraphDataset } from '@/core/models/prescription'\n   Chart.register(...registerables)\n   ```\n\n3. Define props with `withDefaults(defineProps<>())`:\n   ```typescript\n   const props = withDefaults(\n     defineProps<{\n       datasets: GraphDataset[]\n       startHours?: number\n       endHours?: number\n     }>(),\n     { startHours: 0, endHours: 48 }\n   )\n   ```\n\n4. Create canvas ref and chart instance variable:\n   ```typescript\n   const canvasRef = ref<HTMLCanvasElement | null>(null)\n   let chartInstance: Chart | null = null  // NOT reactive\n   ```\n\n5. Write template:\n   ```html\n   <template>\n     <div class=\"graph-viewer\">\n       <div class=\"disclaimer\">Educational purposes only. Not for medical decisions.</div>\n       <div class=\"chart-container\">\n         <canvas ref=\"canvasRef\"></canvas>\n       </div>\n     </div>\n   </template>\n   ```\n\n6. Add scoped CSS:\n   - `.chart-container`: position:relative, height:400px, width:100%\n   - `.disclaimer`: yellow background (#FEF3C7), border, padding, centered text\n\n**Acceptance criteria:**\n- TypeScript passes (`npm run type-check`)\n- Component renders canvas and disclaimer\n- canvasRef binds to canvas element",
            "status": "pending",
            "testStrategy": "Test that component renders canvas element. Test that disclaimer text is visible with correct content. Test that chart-container has correct class. These are the first 3 tests in the spec file.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement renderChart Function with Chart.js Line Configuration",
            "description": "Create the renderChart function that initializes Chart.js with proper configuration for pharmacokinetic curves including linear x/y axes, axis labels, legend, and tooltip formatting with 8-color palette for multi-drug overlay.",
            "dependencies": [
              1
            ],
            "details": "**File to modify:** `src/components/GraphViewer.vue`\n\n**Implementation steps:**\n\n1. Define color palette constant:\n   ```typescript\n   const DEFAULT_COLORS = [\n     '#3B82F6', '#EF4444', '#10B981', '#F59E0B',\n     '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16',\n   ]\n   ```\n\n2. Add tick step helper:\n   ```typescript\n   function calculateTickStep(startHours: number, endHours: number): number {\n     const range = endHours - startHours\n     if (range <= 24) return 2\n     if (range <= 72) return 6\n     if (range <= 168) return 12\n     return 24\n   }\n   ```\n\n3. Implement `renderChart()` function:\n   - Guard: return early if `!canvasRef.value`\n   - Destroy existing: `if (chartInstance) { chartInstance.destroy(); chartInstance = null }`\n   - Guard: return early if `props.datasets.length === 0`\n   - Transform datasets to Chart.js format with color assignment\n   - Create Chart instance with full configuration:\n     - type: 'line'\n     - responsive: true, maintainAspectRatio: false\n     - scales.x: linear, 'Time (hours)', min/max from props\n     - scales.y: linear, 'Relative Concentration (0-1)', min:0, max:1\n     - plugins.legend: display:true, position:'top'\n     - plugins.tooltip: mode:'index', format concentration to 3 decimals\n     - Line options: tension:0.1, pointRadius:0, borderWidth:2\n\n**Data transformation:**\n```typescript\nconst chartDatasets = props.datasets.map((ds, index) => ({\n  label: ds.label,\n  data: ds.data.map(point => ({ x: point.time, y: point.concentration })),\n  borderColor: ds.color || DEFAULT_COLORS[index % DEFAULT_COLORS.length],\n  backgroundColor: 'transparent',\n  tension: 0.1,\n  pointRadius: 0,\n  borderWidth: 2,\n  fill: false,\n}))\n```\n\n**Acceptance criteria:**\n- renderChart creates Chart.js instance with correct configuration\n- X-axis uses startHours/endHours props\n- Y-axis fixed 0-1 range\n- Multiple datasets get distinct colors",
            "status": "pending",
            "testStrategy": "Test Chart.js instance created with correct config (type='line'). Test x-axis min/max matches props. Test y-axis fixed 0-1. Test data transformation to {x,y} format. Test color assignment from palette. Test custom color used when provided in dataset.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Handle Chart Lifecycle with Instance Cleanup and Prop Reactivity",
            "description": "Implement Vue lifecycle hooks (onMounted, onUnmounted) and watchers to manage Chart.js instance creation, updates on prop changes, and proper destruction to prevent memory leaks.",
            "dependencies": [
              2
            ],
            "details": "**File to modify:** `src/components/GraphViewer.vue`\n\n**Implementation steps:**\n\n1. Add mount hook:\n   ```typescript\n   onMounted(() => {\n     renderChart()\n   })\n   ```\n\n2. Add combined watcher for all props:\n   ```typescript\n   watch(\n     [() => props.datasets, () => props.startHours, () => props.endHours],\n     () => {\n       renderChart()\n     },\n     { deep: true },\n   )\n   ```\n   - `deep: true` required for datasets array (detects nested changes)\n   - Combined watcher is cleaner than separate watchers\n\n3. Add unmount cleanup:\n   ```typescript\n   onUnmounted(() => {\n     if (chartInstance) {\n       chartInstance.destroy()\n       chartInstance = null\n     }\n   })\n   ```\n\n**Lifecycle flow:**\n```\nMount -> renderChart() -> Chart created\nProps change -> watch fires -> renderChart() -> old destroyed, new created\nUnmount -> onUnmounted() -> chartInstance.destroy()\n```\n\n**Important:** The destroy-before-create pattern in `renderChart()` (from Phase 2) handles re-renders. The `onUnmounted()` hook handles component removal.\n\n**Edge case handling:**\n- datasets [] -> non-empty: Creates chart\n- datasets non-empty -> []: Destroys chart, leaves canvas blank\n- Component unmounted with no chart: destroy not called (no error)\n\n**Acceptance criteria:**\n- Chart created on mount with provided datasets\n- Chart re-renders when datasets change\n- Chart re-renders when startHours/endHours change\n- Chart destroyed on unmount (no memory leak)\n- No Vue warnings about reactive proxies",
            "status": "pending",
            "testStrategy": "Test chart.destroy() called on unmount. Test chart recreated when datasets change (old destroyed, new created). Test chart recreated when endHours changes. Test empty->filled and filled->empty transitions. Test unmount with empty datasets does not call destroy.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: (1) Set up Chart.js canvas with Vue ref and register all chart modules, (2) Implement renderChart function with proper Chart.js configuration for line charts with linear x/y axes and legend, (3) Handle chart lifecycle (mount/update/unmount) with proper instance cleanup to prevent memory leaks. Include tests for chart creation and props reactivity.",
        "updatedAt": "2026-02-14T15:30:53.790Z"
      },
      {
        "id": "8",
        "title": "Integrate Form, Calculations, and Graph in App.vue",
        "description": "Wire together PrescriptionForm, calculation layer, and GraphViewer in App.vue to create the complete user flow: enter prescription → calculate → display graph → save to storage.",
        "details": "1. Update `src/App.vue`:\n   ```vue\n   <script setup lang=\"ts\">\n   import { ref, computed } from 'vue';\n   import type { Prescription, GraphDataset } from '@/core/models/prescription';\n   import { getGraphData } from '@/core/calculations/pkCalculator';\n   import { savePrescription, getAllPrescriptions } from '@/core/storage/prescriptionStorage';\n   import PrescriptionForm from '@/components/PrescriptionForm.vue';\n   import GraphViewer from '@/components/GraphViewer.vue';\n\n   // State\n   const currentPrescription = ref<Prescription | null>(null);\n   const savedPrescriptions = ref<Prescription[]>(getAllPrescriptions());\n   const showForm = ref(true);\n   const showGraph = ref(false);\n\n   // Graph settings\n   const startHours = ref(0);\n   const endHours = ref(48);\n\n   // Computed graph data\n   const graphDatasets = computed<GraphDataset[]>(() => {\n     if (!currentPrescription.value) return [];\n     return getGraphData([currentPrescription.value], startHours.value, endHours.value);\n   });\n\n   // Handle form submission\n   function handleFormSubmit(rx: Prescription) {\n     currentPrescription.value = rx;\n     showForm.value = false;\n     showGraph.value = true;\n   }\n\n   // Save current prescription\n   function saveCurrentPrescription() {\n     if (currentPrescription.value) {\n       const saved = savePrescription(currentPrescription.value);\n       savedPrescriptions.value = getAllPrescriptions();\n       currentPrescription.value = saved;\n     }\n   }\n\n   // Reset to form\n   function newPrescription() {\n     currentPrescription.value = null;\n     showForm.value = true;\n     showGraph.value = false;\n   }\n   </script>\n\n   <template>\n     <main class=\"app\">\n       <header>\n         <h1>Pharmacokinetics Grapher</h1>\n         <p class=\"subtitle\">Educational visualization of medication concentration</p>\n       </header>\n\n       <div class=\"disclaimer-banner\">\n         ⚠️ This app is for educational purposes only. Not for medical decisions.\n       </div>\n\n       <PrescriptionForm\n         v-if=\"showForm\"\n         @submit=\"handleFormSubmit\"\n       />\n\n       <div v-if=\"showGraph\" class=\"graph-section\">\n         <GraphViewer\n           :datasets=\"graphDatasets\"\n           :startHours=\"startHours\"\n           :endHours=\"endHours\"\n         />\n\n         <div class=\"graph-controls\">\n           <label>Timeframe: {{ startHours }}h to {{ endHours }}h</label>\n           <input type=\"range\" v-model.number=\"endHours\" min=\"12\" max=\"168\" step=\"12\" />\n         </div>\n\n         <div class=\"actions\">\n           <button @click=\"saveCurrentPrescription\">Save Prescription</button>\n           <button @click=\"newPrescription\">New Prescription</button>\n         </div>\n       </div>\n     </main>\n   </template>\n   ```\n\n2. Add basic CSS for layout (flexbox, spacing)\n3. Include prominent educational disclaimers\n4. Wire timeframe slider to graph updates\n<info added on 2026-02-14T14:22:31.137Z>\nBased on my codebase analysis, I can now provide the update text:\n\nPlan and Validation Links (Generated 2026-02-14)\n\nImplementation Plan (persistent, committed to git): thoughts/shared/plans/task8-integrate-form-calc-graph.md - Detailed 3-phase implementation plan with complete reference code\n\nPlan Cache (temporary): .claude/cache/agents/plan-agent/output-2026-02-14-task8.md - Agent workspace copy\n\nValidation Report (temporary): .claude/cache/agents/validate-agent/output-2026-02-14.md - Comprehensive validation against best practices and dependencies\n\nStatus: Plan validated. Ready to implement once blocking tasks complete.\n\nBlocking Dependencies Status (verified 2026-02-14):\n- Task 4 (getGraphData): BLOCKING - Function not yet implemented. multiDose.ts exports accumulateDoses() but getGraphData() is missing. The calculations barrel (src/core/calculations/index.ts) only exports accumulateDoses from multiDose.\n- Task 5 (localStorage storage): DONE - prescriptionStorage.ts fully implemented with getAllPrescriptions(), savePrescription(), and all CRUD operations. Storage barrel (src/core/storage/index.ts) exports all functions.\n- Task 6 (PrescriptionForm.vue): BLOCKING - Component does not exist. src/components/ contains only HelloWorld and boilerplate components.\n- Task 7 (GraphViewer.vue): BLOCKING - Component does not exist in src/components/.\n\nCurrent App.vue State: Default Vue 3 scaffold with HelloWorld/TheWelcome boilerplate (lines 1-48). Must be completely rewritten per plan.\n\nPre-Implementation Action Items:\n1. Task 4: Implement getGraphData() in multiDose.ts and add to calculations barrel export\n2. Task 6: Create PrescriptionForm.vue with @submit event emitting Prescription object\n3. Task 7: Create GraphViewer.vue accepting datasets/startHours/endHours props\n\nEstimated Effort (after dependencies): 2.5 hours total (1-2 hours code + 30 minutes tests)\n</info added on 2026-02-14T14:22:31.137Z>",
        "testStrategy": "1. Manual browser testing:\n   - Enter valid prescription → Graph displays\n   - Verify curve shape (peaks at expected times)\n   - Save prescription → Appears in localStorage (check DevTools)\n   - Adjust timeframe slider → Graph updates\n   - Click New Prescription → Form reappears\n2. Integration test `src/__tests__/App.spec.ts`:\n   - Mount App, fill form, submit, verify graph rendered\n   - Test save updates storage\n3. Test form → graph flow end-to-end\n4. Run `npm run test && npm run dev` for visual verification",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up App.vue state management and computed graph datasets",
            "description": "Initialize reactive state for currentPrescription, view flags (showForm/showGraph), and timeframe settings (startHours/endHours). Create computed property graphDatasets that calls getGraphData when currentPrescription changes.",
            "dependencies": [],
            "details": "1. Import ref, computed from Vue and required types (Prescription, GraphDataset) from @/core/models/prescription\n2. Import getGraphData from @/core/calculations/pkCalculator\n3. Import savePrescription, getAllPrescriptions from @/core/storage/prescriptionStorage\n4. Import PrescriptionForm and GraphViewer components\n5. Create reactive refs: currentPrescription (Prescription | null), savedPrescriptions (Prescription[]), showForm (boolean, default true), showGraph (boolean, default false)\n6. Create timeframe refs: startHours (default 0), endHours (default 48)\n7. Implement computed graphDatasets that returns empty array if no currentPrescription, otherwise calls getGraphData([currentPrescription.value], startHours.value, endHours.value)\n8. Initialize savedPrescriptions with getAllPrescriptions() on component mount",
            "status": "pending",
            "testStrategy": "Unit test the computed graphDatasets: verify it returns empty array when currentPrescription is null, verify it calls getGraphData with correct parameters when prescription exists. Test that refs initialize with correct default values.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement form submission handler and view switching logic",
            "description": "Create handleFormSubmit function that receives prescription from form, updates state, and switches view from form to graph. Implement newPrescription function to reset and return to form view.",
            "dependencies": [
              1
            ],
            "details": "1. Implement handleFormSubmit(rx: Prescription): sets currentPrescription.value = rx, showForm.value = false, showGraph.value = true\n2. Implement newPrescription(): sets currentPrescription.value = null, showForm.value = true, showGraph.value = false\n3. In template: wrap PrescriptionForm in v-if=\"showForm\" and bind @submit=\"handleFormSubmit\"\n4. Create graph-section div with v-if=\"showGraph\" containing GraphViewer\n5. Pass :datasets=\"graphDatasets\", :startHours=\"startHours\", :endHours=\"endHours\" to GraphViewer\n6. Add header with app title, subtitle, and prominent educational disclaimer banner\n7. Add 'New Prescription' button that calls newPrescription()",
            "status": "pending",
            "testStrategy": "Component test: mount App, fill PrescriptionForm, submit, verify GraphViewer renders. Test newPrescription resets state. Integration test: verify form submission triggers graph computation with correct prescription data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add save functionality, timeframe slider, and UI controls",
            "description": "Implement saveCurrentPrescription function that persists to localStorage. Add timeframe slider (12h-168h range) that updates graph in real-time. Style layout with flexbox, spacing, and prominent disclaimers.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Implement saveCurrentPrescription(): if currentPrescription exists, call savePrescription(currentPrescription.value), refresh savedPrescriptions list with getAllPrescriptions(), update currentPrescription to returned saved version (with ID)\n2. Add graph-controls div with timeframe slider: <input type=\"range\" v-model.number=\"endHours\" min=\"12\" max=\"168\" step=\"12\" /> with label showing current range\n3. Add actions div with 'Save Prescription' button (@click=\"saveCurrentPrescription\") and 'New Prescription' button\n4. Add scoped CSS: .app container with max-width and padding, .disclaimer-banner with warning styling (yellow/orange background), .graph-section with flexbox layout, .graph-controls and .actions with proper spacing\n5. Ensure disclaimer text states: 'This app is for educational purposes only. Not for medical decisions.'\n6. Test that slider changes update graphDatasets reactively (computed will recalculate)",
            "status": "pending",
            "testStrategy": "Integration test: submit prescription, click save, verify localStorage contains prescription via getAllPrescriptions(). Test slider: change endHours value, verify graphDatasets recomputes. Manual test: verify slider updates graph visualization in browser.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: (1) Set up App state (currentPrescription, showForm/showGraph flags, timeframe settings) and computed graphDatasets, (2) Implement form submission handler and view switching logic, (3) Add save functionality with storage integration and UI controls (slider, action buttons). Include integration tests for the complete flow.",
        "updatedAt": "2026-02-14T15:32:53.187Z"
      },
      {
        "id": "9",
        "title": "Implement Prescription List and Management Component",
        "description": "Create PrescriptionList component with CRUD operations (view, edit, delete, duplicate), compare mode for multi-drug overlay, and quick preview thumbnails.",
        "status": "done",
        "dependencies": [
          "5",
          "6",
          "7",
          "8"
        ],
        "priority": "medium",
        "details": "Implementation plan finalized in `thoughts/shared/plans/task9-prescription-list-component.md`. The component uses the existing storage module (`src/core/storage/prescriptionStorage.ts`) which exports `getAllPrescriptions()`, `deletePrescription(id)`, and `duplicatePrescription(id)`. The `Prescription` type from `src/core/models/prescription.ts` has optional `id?: string` requiring guards on id-based operations.\n\n**Key implementation decisions:**\n1. Vue 3 Composition API with `<script setup lang=\"ts\">`\n2. Storage functions already exist and return proper types (`deletePrescription` returns boolean, `duplicatePrescription` returns `Prescription | undefined`)\n3. Vue reactivity with Set requires replacing the entire Set on mutations (not in-place `.add()`/`.delete()`)\n4. Component emits `view`, `edit`, `compare` events to parent - no props needed\n5. Use `data-testid` attributes for reliable test selectors\n\n**Files to create:**\n- `src/components/PrescriptionList.vue` - main component\n- `src/components/__tests__/PrescriptionList.spec.ts` - ~20 tests\n- `src/components/__tests__/prescriptionListFixtures.ts` - mock data\n\n**Component structure:**\n- Reactive state: `prescriptions: ref<Prescription[]>`, `compareMode: ref<boolean>`, `selectedIds: ref<Set<string>>`\n- Computed: `selectedCount`\n- Handlers: `refresh()`, `handleDelete(id)`, `handleDuplicate(id)`, `handleEdit(rx)`, `toggleSelect(id)`, `handleCompare()`, `exitCompareMode()`\n- Template: header with compare toggle, empty state, prescription list with action buttons, floating compare bar\n\n**Edge cases handled:**\n- `id` is optional - guard all id-dependent operations with `rx.id &&`\n- Delete while in compare mode cleans up `selectedIds`\n- Set reactivity requires full Set replacement\n- `window.confirm` for delete confirmation\n<info added on 2026-02-14T14:43:12.051Z>\nBased on the TLDR output and the implementation plan, I have sufficient context. The storage module exports the needed functions (`getAllPrescriptions`, `deletePrescription`, `duplicatePrescription`), and the plan file is comprehensive. Let me generate the task update text.\n\n## Plan & Validation Links (Generated 2026-02-14)\n\n**Implementation Plan** (persistent, committed to git):\n- `thoughts/shared/plans/task9-prescription-list-component.md` - Detailed 3-phase implementation plan with CRUD operations, compare mode, and test strategy\n\n**Plan Cache** (temporary):\n- `.claude/cache/agents/plan-agent/output-2026-02-14-task9.md` - Agent workspace copy\n\n**Validation Report** (status: pending validation):\n- Validation report to be generated - comprehensive validation against best practices\n\n**Status**: Plan created and ready for validation.\n\n**Blocking Dependencies**:\n- Task 5 (localStorage Storage) - DONE (verified: `src/core/storage/prescriptionStorage.ts` exports `getAllPrescriptions()`, `deletePrescription()`, `duplicatePrescription()` via `src/core/storage/index.ts`)\n- Task 6 (PrescriptionForm Component) - Pending (required for edit flow handoff)\n- Task 7 (GraphViewer Component) - Pending (required for view and compare flows)\n- Task 8 (App.vue Integration) - Pending (required for parent event handlers)\n\n**Key Implementation Notes**:\n- Vue 3 Composition API with Set for compare mode selection\n- CRITICAL: Set mutations require full Set replacement for Vue reactivity (`selectedIds.value = new Set([...selectedIds.value, id])`)\n- Optional `id` field requires guards on all id-based operations (`rx.id && handleDelete(rx.id)`)\n- Storage functions verified in `src/core/storage/index.ts`: `getAllPrescriptions`, `deletePrescription`, `duplicatePrescription` (plus `getPrescription`, `savePrescription`, `updatePrescription`, `clearAllPrescriptions`, `getStorageUsage`)\n\n**Estimated Effort** (after dependencies): 2-2.5 hours total across 3 subtasks\n</info added on 2026-02-14T14:43:12.051Z>",
        "testStrategy": "Create `src/components/__tests__/PrescriptionList.spec.ts` with ~20 tests organized by feature:\n\n**Mock strategy:**\n```typescript\nvi.mock('@/core/storage/prescriptionStorage', () => ({\n  getAllPrescriptions: vi.fn(() => []),\n  deletePrescription: vi.fn(() => true),\n  duplicatePrescription: vi.fn(),\n}))\n```\n\n**Test categories:**\n1. Empty state (2 tests): renders message when no prescriptions\n2. List rendering (3 tests): correct count, displays name/frequency/dose/halfLife\n3. View action (1 test): emits `view` with prescription payload\n4. Edit action (1 test): emits `edit` with prescription payload\n5. Delete action (3 tests): confirm dialog, delete on confirm, no delete on cancel\n6. Duplicate action (2 tests): calls `duplicatePrescription`, refreshes list\n7. Compare mode toggle (2 tests): toggle button, checkboxes appear\n8. Compare selection (4 tests): add/remove from Set, selected count updates\n9. Compare submission (2 tests): emits `compare` with selected array\n\n**Mock `window.confirm`:**\n```typescript\nconst confirmSpy = vi.spyOn(window, 'confirm').mockReturnValue(true)\n```\n\n**Verification commands:**\n```bash\nnpm run test:unit -- src/components/__tests__/PrescriptionList.spec.ts\nnpm run type-check\nnpm run lint\n```",
        "subtasks": [
          {
            "id": 1,
            "title": "Create List Display with Empty State and Prescription Item Rendering",
            "description": "Implement the base PrescriptionList.vue component structure with reactive state for displaying saved prescriptions, including empty state handling when no prescriptions exist and individual prescription item rendering with key details.",
            "dependencies": [],
            "details": "Create `src/components/PrescriptionList.vue` with Vue 3 Composition API. Import `Prescription` type from `@/core/models/prescription` and `getAllPrescriptions` from `@/core/storage/prescriptionStorage` (verified export from `src/core/storage/index.ts`). Set up reactive state with `ref<Prescription[]>` initialized from `getAllPrescriptions()`. Implement `refresh()` function that re-fetches prescriptions from storage. Template structure includes empty state div with data-testid when prescriptions.length equals 0, ul with li v-for each displaying name (bold), frequency badge, dose with mg suffix, and half-life with h suffix. Create test fixtures at src/components/__tests__/prescriptionListFixtures.ts with mock prescriptions matching the Prescription interface. Add scoped CSS for list layout with flexbox and visual hierarchy.",
            "status": "pending",
            "testStrategy": "Create src/components/__tests__/PrescriptionList.spec.ts using Vitest and Vue Test Utils. Mock @/core/storage/prescriptionStorage at module level. Test empty state message renders when mock returns empty array. Test list items render with correct count when mock returns MOCK_PRESCRIPTIONS. Verify prescription details display correctly. Test refresh() updates list after mock changes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CRUD Action Handlers with Event Emissions",
            "description": "Add action buttons (View, Edit, Duplicate, Delete) to each prescription item and implement handler functions that either emit events to parent components or mutate localStorage with proper confirmation flows.",
            "dependencies": [
              1
            ],
            "details": "Define typed emits for edit, compare, and view events. Import deletePrescription and duplicatePrescription from storage module. Note that deletePrescription(id) returns boolean and duplicatePrescription(id) returns Prescription or undefined. Implement handleDelete(id) with confirm dialog that also removes id from selectedIds if in compare mode then refreshes. Implement handleDuplicate(id) that calls duplicatePrescription then refreshes. Implement handleEdit(rx) that emits edit event. Add template action buttons with data-testid attributes for View, Edit, Duplicate, Delete. Guard all id-based operations with rx.id check since id is optional in Prescription type. Style danger button with red color.",
            "status": "pending",
            "testStrategy": "Add tests to PrescriptionList.spec.ts: Click View button verifies view event emitted with correct prescription using wrapper.emitted(). Click Edit verifies edit event. Mock window.confirm returning true, click Delete, verify deletePrescription called and list refreshes. Mock confirm returning false, verify item NOT removed. Click Duplicate verifies duplicatePrescription called with correct id.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Compare Mode with Multi-Select Checkbox UI",
            "description": "Add compare mode toggle and checkbox selection system allowing users to select multiple prescriptions for side-by-side comparison, using Set<string> for efficient selection state management.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add reactive state for compareMode boolean and selectedIds Set. Add selectedCount computed property. CRITICAL for Vue reactivity with Set: must replace entire Set on mutations using new Set pattern in toggleSelect function. Implement handleCompare() that filters prescriptions by selectedIds and emits compare event if selected.length greater than 0. Implement exitCompareMode() that sets compareMode false and clears selectedIds. Add header toggle button with data-testid. Add checkbox per item conditionally shown when compareMode true with checked binding and change handler. Add compare bar div shown when compareMode AND selectedCount greater than 0 containing count display and submit button. Add CSS for sticky compare bar, checkbox alignment, and selection highlighting.",
            "status": "pending",
            "testStrategy": "Add tests: Toggle compare mode button toggles compareMode and checkboxes appear. Click checkbox adds id to Set, click again removes. Verify selectedCount reflects correct count. Select 2 items, click Compare Selected, verify compare event with array of 2 prescriptions. Exit compare mode clears selectedIds. Compare bar only visible when compareMode AND selectedCount greater than 0.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: (1) Create list display with empty state handling and prescription item rendering using getAllPrescriptions from existing storage module, (2) Implement CRUD action handlers (delete with window.confirm, duplicate via duplicatePrescription, edit/view emit events to parent), (3) Implement compare mode with Set-based selection state requiring full Set replacement for Vue reactivity. Include ~20 component tests mocking @/core/storage/prescriptionStorage module.",
        "updatedAt": "2026-02-14T21:21:14.960Z"
      },
      {
        "id": "10",
        "title": "Add Multi-Drug Comparison and Complete MVP Polish",
        "description": "Integrate PrescriptionList into App.vue, implement multi-drug graph overlay from compare mode, add comprehensive test coverage, and polish UI with accessibility features.",
        "details": "1. Update `src/App.vue` to include PrescriptionList:\n   ```vue\n   <script setup lang=\"ts\">\n   // ... existing code ...\n   import PrescriptionList from '@/components/PrescriptionList.vue';\n\n   const viewMode = ref<'form' | 'graph' | 'list'>('form');\n   const comparePrescriptions = ref<Prescription[]>([]);\n\n   // Multi-drug graph data\n   const multiGraphDatasets = computed<GraphDataset[]>(() => {\n     if (comparePrescriptions.value.length === 0) return [];\n     return getGraphData(comparePrescriptions.value, startHours.value, endHours.value);\n   });\n\n   function handleCompare(prescriptions: Prescription[]) {\n     comparePrescriptions.value = prescriptions;\n     viewMode.value = 'graph';\n   }\n\n   function handleEditFromList(rx: Prescription) {\n     currentPrescription.value = rx;\n     viewMode.value = 'form';\n   }\n\n   function handleViewFromList(rx: Prescription) {\n     currentPrescription.value = rx;\n     comparePrescriptions.value = [rx];\n     viewMode.value = 'graph';\n   }\n   </script>\n\n   <template>\n     <!-- Navigation tabs -->\n     <nav class=\"tabs\">\n       <button :class=\"{ active: viewMode === 'form' }\" @click=\"viewMode = 'form'\">Add New</button>\n       <button :class=\"{ active: viewMode === 'list' }\" @click=\"viewMode = 'list'\">Saved</button>\n     </nav>\n\n     <!-- Conditional views -->\n     <PrescriptionForm v-if=\"viewMode === 'form'\" :initial=\"currentPrescription\" @submit=\"handleFormSubmit\" />\n     <PrescriptionList v-if=\"viewMode === 'list'\" @edit=\"handleEditFromList\" @view=\"handleViewFromList\" @compare=\"handleCompare\" />\n     <GraphViewer v-if=\"viewMode === 'graph'\" :datasets=\"multiGraphDatasets\" />\n   </template>\n   ```\n\n2. Add comprehensive accessibility:\n   - ARIA labels on all form inputs\n   - Keyboard navigation for tabs\n   - Focus management on view changes\n   - High contrast color scheme\n\n3. Polish styling:\n   - Consistent spacing and typography\n   - Responsive layout for tablet\n   - Print-friendly graph view\n\n4. Add integration tests for full flows:\n   - form → save → list → compare → graph\n   - edit from list → modify → save\n\n5. Run full test suite and fix any gaps:\n   ```bash\n   npm run test -- --coverage\n   npm run type-check\n   npm run lint\n   ```",
        "testStrategy": "1. Run full test suite with coverage: `npm run test -- --coverage`\n   - Target: >85% overall, >95% calculations\n2. Manual testing checklist:\n   - [ ] Add prescription → graph displays correctly\n   - [ ] Save → appears in list\n   - [ ] Edit from list → form populated → modify → save\n   - [ ] Delete with confirmation\n   - [ ] Duplicate creates copy\n   - [ ] Compare 2+ drugs → overlay graph\n   - [ ] Timeframe slider updates graph\n   - [ ] Edge cases: ka≈ke, extreme half-lives\n3. Accessibility testing:\n   - Tab through all controls\n   - Screen reader test on form labels\n   - Color contrast check\n4. Browser testing: Chrome, Firefox, Safari\n5. Run `npm run build && npm run preview` - verify production build",
        "priority": "medium",
        "dependencies": [
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update App.vue with View Mode State and Navigation Tabs",
            "description": "Add view mode state management (form/graph/list) to App.vue with navigation tabs for switching between views, import PrescriptionList component, and wire up the multi-prescription comparison state.",
            "dependencies": [],
            "details": "1. Add `viewMode` ref with type `'form' | 'graph' | 'list'` defaulting to 'form'\n2. Add `comparePrescriptions` ref as `Prescription[]` for multi-drug comparison\n3. Create computed `multiGraphDatasets` that calls `getGraphData(comparePrescriptions.value, startHours.value, endHours.value)`\n4. Import PrescriptionList component\n5. Add navigation tabs in template with active state styling based on viewMode\n6. Implement keyboard navigation (Tab/Enter/Space) for tab switching\n7. Use v-if to conditionally render PrescriptionForm, PrescriptionList, or GraphViewer based on viewMode",
            "status": "pending",
            "testStrategy": "1. Unit test: viewMode ref starts as 'form'\n2. Unit test: clicking tab updates viewMode\n3. Unit test: keyboard Enter/Space triggers tab selection\n4. Integration test: switching tabs shows correct component\n5. Verify focus management when switching views",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Multi-Prescription Graph Overlay via Compare Event",
            "description": "Connect PrescriptionList compare event to GraphViewer, enabling users to select multiple prescriptions and view overlaid concentration curves on a single graph.",
            "dependencies": [
              1
            ],
            "details": "1. Create `handleCompare(prescriptions: Prescription[])` that sets comparePrescriptions and switches to graph view\n2. Create `handleEditFromList(rx: Prescription)` to populate form with existing prescription for editing\n3. Create `handleViewFromList(rx: Prescription)` to view single prescription graph\n4. Wire PrescriptionList events: @edit, @view, @compare to respective handlers\n5. Pass multiGraphDatasets to GraphViewer with distinct colors per prescription\n6. Ensure legend displays drug name and frequency for each overlaid curve\n7. Each curve normalized to its own peak=1.0 (per CLAUDE.md: no cross-drug normalization)",
            "status": "pending",
            "testStrategy": "1. Unit test: handleCompare sets comparePrescriptions and viewMode='graph'\n2. Unit test: handleEditFromList sets currentPrescription and viewMode='form'\n3. Integration test: select 2 drugs in list → click compare → graph shows 2 curves\n4. Visual test: verify legend shows both drug names with correct colors",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Accessibility Improvements (ARIA, Keyboard, Focus)",
            "description": "Implement comprehensive accessibility features including ARIA labels on form inputs, keyboard navigation for tabs and interactive elements, focus management on view changes, and high contrast color scheme.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Add ARIA labels to all form inputs (drug name, dose, frequency, times, half-life, uptake)\n2. Add role='tablist' to navigation container, role='tab' to each tab button\n3. Add aria-selected, aria-controls, tabindex to tabs\n4. Implement arrow key navigation between tabs (Left/Right arrows)\n5. Add focus management: when viewMode changes, focus first interactive element in new view\n6. Use :focus-visible for visible focus indicators\n7. Add high contrast color scheme via CSS custom properties (--color-primary, --color-text, etc.)\n8. Ensure graph has aria-label describing data ('Concentration curves for [drug names]')\n9. Add skip-to-content link for keyboard users",
            "status": "pending",
            "testStrategy": "1. Automated a11y audit using vue-axe or similar\n2. Manual keyboard-only navigation test (Tab through entire app)\n3. Screen reader test: verify labels are announced correctly\n4. Test arrow key navigation between tabs\n5. Verify focus moves to correct element on view change",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Comprehensive Testing Pass with Coverage Reporting",
            "description": "Run full test suite with coverage reporting, add missing integration tests for complete user flows, perform cross-browser verification, and ensure >85% test coverage threshold is met.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Run `npm run test -- --coverage` and identify coverage gaps\n2. Add integration tests for full flows:\n   - form → save → list → compare → graph (multi-drug overlay)\n   - edit from list → modify form → save → verify updated in list\n3. Add tests for edge cases: empty list state, single vs multiple selection\n4. Run `npm run type-check` and fix any TypeScript errors\n5. Run `npm run lint` and fix linting issues\n6. Cross-browser testing: Chrome, Firefox, Safari (manual)\n7. Responsive testing: verify tablet layout (768px-1024px width)\n8. Verify coverage targets: >85% overall, >95% for src/core/calculations\n9. Document any known issues or limitations in test output",
            "status": "pending",
            "testStrategy": "1. Coverage report must show >85% statements, branches, functions\n2. All integration tests pass: form→save→list→compare→graph flow\n3. Type-check passes with zero errors\n4. ESLint passes with zero errors\n5. Manual verification in Chrome, Firefox, Safari\n6. Responsive breakpoints tested at 768px and 1024px",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Refactor App.vue state from booleans to viewMode enum",
            "description": "Replace showForm/showGraph boolean state with a single viewMode ref of type 'form' | 'graph' | 'list' to support three-way navigation between form, graph, and prescription list views.",
            "dependencies": [],
            "details": "In src/App.vue, replace `const showForm = ref(true)` and `const showGraph = ref(false)` with `const viewMode = ref<'form' | 'graph' | 'list'>('form')`. Update all conditional rendering in template from `v-if=\"showForm\"` to `v-if=\"viewMode === 'form'\"` and similarly for graph. Update event handlers: handleFormSubmit should set `viewMode.value = 'graph'`, newPrescription should set `viewMode.value = 'form'`. This is a prerequisite for adding the list view.",
            "status": "pending",
            "testStrategy": "Run existing tests to ensure they still pass after refactor. Manually verify form submission still transitions to graph view and 'New Prescription' button returns to form view.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add comparePrescriptions ref and multiGraphDatasets computed",
            "description": "Add state for tracking multiple prescriptions selected for comparison and compute the corresponding graph datasets for multi-drug overlay visualization.",
            "dependencies": [
              5
            ],
            "details": "Add `const comparePrescriptions = ref<Prescription[]>([])` to hold prescriptions selected for comparison. Add computed property `const multiGraphDatasets = computed<GraphDataset[]>(() => { if (comparePrescriptions.value.length === 0) return []; return getGraphData(comparePrescriptions.value, startHours.value, endHours.value); })`. Update the GraphViewer binding to use multiGraphDatasets when in compare mode, falling back to graphDatasets for single prescription view. Import getGraphData from @/core/calculations.",
            "status": "pending",
            "testStrategy": "Write unit test verifying multiGraphDatasets returns empty array when comparePrescriptions is empty, and returns correctly formatted datasets when prescriptions are present.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Import and integrate PrescriptionList component into App.vue",
            "description": "Import PrescriptionList component and add it to the template with conditional rendering based on viewMode, positioned between the form and graph views.",
            "dependencies": [
              5
            ],
            "details": "Add `import PrescriptionList from '@/components/PrescriptionList.vue'` to App.vue script. Add to template: `<PrescriptionList v-if=\"viewMode === 'list'\" @edit=\"handleEditFromList\" @view=\"handleViewFromList\" @compare=\"handleCompare\" />`. Position after PrescriptionForm in the template. The PrescriptionList component already emits 'edit', 'view', and 'compare' events as defined in its implementation.",
            "status": "pending",
            "testStrategy": "Manually verify PrescriptionList renders when viewMode is 'list'. Verify the component receives no props initially (it manages its own state via getAllPrescriptions).",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement event handlers for PrescriptionList interactions",
            "description": "Create handleEditFromList, handleViewFromList, and handleCompare functions to wire up the PrescriptionList component events to App.vue state management.",
            "dependencies": [
              6,
              7
            ],
            "details": "Add three handler functions: (1) `function handleEditFromList(rx: Prescription) { currentPrescription.value = rx; viewMode.value = 'form'; }` - sets prescription in form for editing. (2) `function handleViewFromList(rx: Prescription) { currentPrescription.value = rx; comparePrescriptions.value = [rx]; viewMode.value = 'graph'; }` - views single prescription graph. (3) `function handleCompare(prescriptions: Prescription[]) { comparePrescriptions.value = prescriptions; viewMode.value = 'graph'; }` - handles multi-drug comparison. Update PrescriptionForm to accept and populate from currentPrescription when editing.",
            "status": "pending",
            "testStrategy": "Write integration test: mount App.vue with mocked storage, trigger edit event from PrescriptionList, verify form populates with prescription data. Test compare event triggers graph view with multiple datasets.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Add navigation tabs for view switching",
            "description": "Create a navigation component with tabs for 'Add New', 'Saved', and optionally 'Graph' views to allow users to switch between different sections of the application.",
            "dependencies": [
              5
            ],
            "details": "Add navigation tabs in App.vue template above main content: `<nav class=\"tabs\" role=\"tablist\"><button role=\"tab\" :aria-selected=\"viewMode === 'form'\" :class=\"{ active: viewMode === 'form' }\" @click=\"viewMode = 'form'\">Add New</button><button role=\"tab\" :aria-selected=\"viewMode === 'list'\" :class=\"{ active: viewMode === 'list' }\" @click=\"viewMode = 'list'\">Saved</button></nav>`. Add CSS for .tabs styling with flexbox layout, active state with border-bottom highlight, hover states. Support keyboard navigation with arrow keys.",
            "status": "pending",
            "testStrategy": "Test tab switching updates viewMode correctly. Verify ARIA attributes (role=\"tablist\", role=\"tab\", aria-selected) are applied correctly. Test keyboard navigation between tabs.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Add ARIA labels and accessibility improvements to form inputs",
            "description": "Enhance PrescriptionForm accessibility by adding ARIA labels, improving focus management, and ensuring screen reader compatibility for all form elements.",
            "dependencies": [],
            "details": "Review PrescriptionForm.vue - many aria-describedby attributes already exist. Add missing ARIA: (1) Add aria-label to frequency select, (2) Add aria-required=\"true\" to required fields, (3) Ensure fieldset/legend for dosing times has proper accessibility, (4) Add aria-invalid=\"true\" when validation fails on specific fields, (5) Ensure error messages are associated with fields via aria-describedby. Test with screen reader (VoiceOver on macOS).",
            "status": "pending",
            "testStrategy": "Run accessibility audit using axe-core or similar tool. Manually test with VoiceOver - verify all form fields are announced correctly with labels and hints. Verify validation errors are announced.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Implement keyboard navigation and focus management",
            "description": "Add keyboard navigation support for tabs and ensure proper focus management when switching between views to improve accessibility.",
            "dependencies": [
              9
            ],
            "details": "Add keyboard event handlers to navigation tabs: (1) Arrow Left/Right to move between tabs, (2) Home/End to jump to first/last tab, (3) Enter/Space to activate tab. Implement focus management: when viewMode changes, move focus to the first focusable element in the new view (e.g., first form input, first list item, or graph container). Add tabindex=\"0\" to graph container for focus. Use Vue's nextTick to ensure DOM is updated before focusing.",
            "status": "pending",
            "testStrategy": "Test keyboard navigation: Tab to nav, arrow keys to move between tabs, Enter to activate. Verify focus moves to appropriate element when view changes. Test with keyboard-only navigation (no mouse).",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Write App.vue integration tests for multi-drug comparison flow",
            "description": "Create comprehensive integration tests for the complete user flow: form submission, saving, listing, selecting multiple prescriptions, and comparing on graph.",
            "dependencies": [
              8
            ],
            "details": "Create src/components/__tests__/App.spec.ts with tests: (1) form → submit → graph displays single prescription, (2) save → list → verify prescription appears, (3) list → edit → form populated → modify → save → list updated, (4) list → compare mode → select 2 → compare → graph with 2 datasets, (5) view single from list → graph with 1 dataset. Mock localStorage. Test state transitions between viewMode values. Verify GraphViewer receives correct datasets prop.",
            "status": "pending",
            "testStrategy": "Run npm run test -- src/components/__tests__/App.spec.ts. Verify all flows pass. Check coverage meets >85% target for App.vue.",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Add responsive layout improvements for tablet/mobile",
            "description": "Polish responsive CSS for tablet breakpoints, ensuring navigation tabs, form layout, and graph viewer adapt properly to different screen sizes.",
            "dependencies": [
              9
            ],
            "details": "Update App.vue styles: (1) Tabs should stack vertically on mobile (<480px), (2) Graph controls should be full-width on tablet, (3) Add print media query for graph-only view without navigation. Update PrescriptionList.vue: (1) Stack action buttons vertically on mobile, (2) Reduce padding on smaller screens. Test on common breakpoints: 320px, 480px, 768px, 1024px. Ensure touch targets are at least 44x44px for mobile accessibility.",
            "status": "pending",
            "testStrategy": "Visual testing at multiple viewport sizes using browser dev tools. Verify layout doesn't break. Test touch interactions on mobile simulator. Verify print preview shows graph cleanly.",
            "parentId": "undefined"
          },
          {
            "id": 14,
            "title": "Run full test suite and achieve coverage targets",
            "description": "Execute complete test suite with coverage reporting, identify and fix any gaps, and ensure all tests pass with >85% overall coverage.",
            "dependencies": [
              12
            ],
            "details": "Run `npm run test -- --coverage` to generate coverage report. Target: >85% overall, >95% for src/core/calculations. Review uncovered lines and add tests where needed. Run `npm run type-check` to verify TypeScript types. Run `npm run lint` and fix any linting issues. Create a pre-commit checklist document summarizing the verification steps. Address any test failures from previous subtasks.",
            "status": "pending",
            "testStrategy": "Coverage report shows >85% overall. All tests pass (0 failures). Type-check passes with no errors. Lint passes with no warnings. Manual testing checklist completed for key user flows.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: (1) Update App.vue with viewMode state (form/graph/list) and navigation tabs - add comparePrescriptions ref and multiGraphDatasets computed, (2) Wire PrescriptionList events (@edit, @view, @compare) to handlers that set state and switch views, GraphViewer already supports multiple datasets, (3) Add accessibility improvements (ARIA labels on form inputs, keyboard tab navigation, focus management), (4) Comprehensive testing pass with coverage >85%, integration tests for full flows (form→save→list→compare→graph), cross-browser verification.",
        "updatedAt": "2026-02-14T21:50:30.521Z"
      },
      {
        "id": "11",
        "title": "Add legend to graphs showing medication names",
        "description": "Graph needs to display medication names as a legend so users can identify which curves correspond to which medications when multiple prescriptions are graphed.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit existing legend implementation in GraphViewer.vue",
            "description": "Review the current Chart.js legend configuration (lines 116-120) and identify gaps in functionality for multi-drug visualization.",
            "dependencies": [],
            "details": "Examine GraphViewer.vue's plugins.legend configuration. Current implementation: display=true, position='top', usePointStyle=true, padding=16. Document what's missing: interactive toggling, better styling, responsive behavior, accessibility attributes.",
            "status": "pending",
            "testStrategy": "Manual review - no code changes in this subtask",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enhance legend label formatting with dose information",
            "description": "Update getGraphData() in multiDose.ts to include dose amount in legend labels for better medication identification.",
            "dependencies": [
              1
            ],
            "details": "Modify multiDose.ts line 131 to format labels as 'DrugName (dose mg, frequency)' instead of just 'DrugName (frequency)'. This provides more context when multiple drugs are displayed. Update corresponding unit tests in multiDose.spec.ts.",
            "status": "pending",
            "testStrategy": "Unit test: verify getGraphData returns labels with dose information; test edge cases like decimal doses",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add interactive legend click handlers for curve toggling",
            "description": "Implement Chart.js legend onClick handlers to allow users to show/hide individual medication curves by clicking legend items.",
            "dependencies": [
              1
            ],
            "details": "Add onClick and onHover callbacks to plugins.legend configuration. Use Chart.js built-in visibility toggling via chart.getDatasetMeta(index).hidden. Maintain visual feedback (opacity change) when curves are hidden.",
            "status": "pending",
            "testStrategy": "Component test: mock Chart.js and verify onClick callback is configured; manual test curve visibility toggle",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Style legend items with matching curve colors and icons",
            "description": "Configure Chart.js legend to display colored line icons that match the curve colors for better visual association.",
            "dependencies": [
              1
            ],
            "details": "In GraphViewer.vue legend config: set boxWidth, boxHeight for consistent sizing, ensure usePointStyle renders line markers. Configure generateLabels callback if needed for custom styling. Match colors from DEFAULT_COLORS palette.",
            "status": "pending",
            "testStrategy": "Visual verification: legend color boxes should match curve colors; screenshot comparison if available",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement responsive legend positioning",
            "description": "Add responsive legend positioning that switches from top to bottom/right based on screen size and number of medications.",
            "dependencies": [
              1,
              4
            ],
            "details": "Add responsive legend behavior: position='top' for desktop, consider position='bottom' for mobile via CSS media queries or Chart.js responsive callbacks. Handle legend overflow when many drugs are displayed (maxWidth, textWrap).",
            "status": "pending",
            "testStrategy": "Component test: verify legend position prop changes on viewport resize; manual mobile testing",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add legend hover tooltip with medication details",
            "description": "Implement custom hover behavior on legend items to show detailed medication information in a tooltip popup.",
            "dependencies": [
              3,
              4
            ],
            "details": "Use Chart.js onHover legend callback to display tooltip with: full drug name, dose, frequency label (e.g., 'twice daily' for bid), half-life, peak time. May require custom HTML tooltip overlay positioned relative to legend item.",
            "status": "pending",
            "testStrategy": "Component test: verify onHover callback triggers; manual test tooltip content and positioning",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Write unit tests for enhanced legend configuration",
            "description": "Add comprehensive tests to GraphViewer.spec.ts covering all new legend functionality.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Add test cases: legend displays correct medication names with dose, onClick handler is configured for toggling, legend items have correct colors matching curves, legend position is configurable. Use existing mock pattern from GraphViewer.spec.ts.",
            "status": "pending",
            "testStrategy": "Vitest unit tests covering: legend config structure, callback presence, color mapping, multi-dataset labels",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Add accessibility attributes to legend elements",
            "description": "Ensure legend is keyboard-navigable and screen reader friendly with proper ARIA attributes.",
            "dependencies": [
              3,
              6
            ],
            "details": "Chart.js generates canvas-based legends by default. Consider: enable HTML legend plugin for better a11y, add aria-labels describing medication curves, ensure Tab navigation works for legend items, provide focus indicators.",
            "status": "pending",
            "testStrategy": "Manual a11y testing: keyboard navigation, screen reader announcement; consider axe-core automated checks",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Update GraphDataset interface to support legend metadata",
            "description": "Extend GraphDataset type to include optional legendMetadata field for enhanced tooltip information.",
            "dependencies": [
              6
            ],
            "details": "In src/core/models/prescription.ts, add optional 'legendMetadata' property to GraphDataset interface containing: fullName, dose, doseUnit, frequencyLabel, halfLife, peakTime. Update multiDose.ts getGraphData() to populate this metadata.",
            "status": "pending",
            "testStrategy": "Unit test: verify GraphDataset with legendMetadata compiles and getGraphData populates it correctly",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Integration test legend with multiple prescriptions",
            "description": "Create end-to-end test verifying legend displays correctly when multiple medications are graphed simultaneously.",
            "dependencies": [
              7,
              8,
              9
            ],
            "details": "Test scenario: add 3+ prescriptions with different names/frequencies, verify legend shows all entries with distinct colors, verify clicking legend toggles curve visibility, verify tooltip shows correct medication details on hover. Test color palette cycling for 8+ medications.",
            "status": "pending",
            "testStrategy": "Integration test using vue-test-utils: mount App with multiple prescriptions, verify legend rendering and interactions",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Verify existing legend displays correctly with multiple medications",
            "description": "Manually test that the current Chart.js legend implementation shows medication names when multiple prescriptions are graphed simultaneously.",
            "dependencies": [],
            "details": "Open the app, add 2-3 test prescriptions with different names and frequencies, enable compare mode, and verify the legend appears at the top showing each medication's name and frequency. Confirm colors in legend match the curve colors on the graph.",
            "status": "pending",
            "testStrategy": "Manual browser testing: add prescriptions 'Aspirin (bid)', 'Ibuprofen (tid)', 'Acetaminophen (qid)' and verify all three appear in legend with correct colors.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Enhance label format to include dose information",
            "description": "Update getGraphData in multiDose.ts to include the dose amount in the legend label for better identification.",
            "dependencies": [
              11
            ],
            "details": "Modify line 131 in multiDose.ts to change label from `${rx.name} (${rx.frequency})` to `${rx.name} ${rx.dose}mg (${rx.frequency})`. This gives users more context about each curve without cluttering the graph.",
            "status": "pending",
            "testStrategy": "Unit test: verify getGraphData returns label format 'DrugName 500mg (bid)'. Visual test: confirm legend displays updated format.",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Add click-to-toggle visibility for legend items",
            "description": "Verify and document that Chart.js built-in legend click behavior allows users to show/hide individual medication curves.",
            "dependencies": [
              11
            ],
            "details": "Chart.js legends have built-in click-to-toggle functionality by default. Test that clicking a legend item hides/shows the corresponding curve. If not working, enable with onClick handler in legend config. Document this feature for users.",
            "status": "pending",
            "testStrategy": "Manual test: click legend item, verify curve disappears. Click again, verify curve reappears. Test with multiple medications.",
            "parentId": "undefined"
          },
          {
            "id": 14,
            "title": "Synchronize color palettes between GraphViewer and multiDose",
            "description": "Ensure color arrays in GraphViewer.vue and multiDose.ts are consistent to prevent color mismatches.",
            "dependencies": [
              11
            ],
            "details": "Compare DEFAULT_COLORS in GraphViewer.vue (8 colors) with colors array in multiDose.ts (5 colors). Either consolidate to a shared constant in a separate file, or ensure multiDose.ts uses the full 8-color palette. This prevents edge cases where >5 medications show inconsistent colors.",
            "status": "pending",
            "testStrategy": "Add 6+ prescriptions and verify each has a unique, consistent color in both legend and curve.",
            "parentId": "undefined"
          },
          {
            "id": 15,
            "title": "Add unit tests for legend label generation",
            "description": "Create unit tests verifying getGraphData produces correct labels for various prescription configurations.",
            "dependencies": [
              12
            ],
            "details": "Add tests to multiDose.spec.ts covering: single prescription label format, multiple prescriptions each get unique labels, labels include name/dose/frequency, special characters in drug names are handled, empty name edge case.",
            "status": "pending",
            "testStrategy": "Write Vitest tests asserting label format matches expected pattern for various inputs including edge cases.",
            "parentId": "undefined"
          },
          {
            "id": 16,
            "title": "Add hover tooltip enhancement for legend items",
            "description": "Configure legend labels to show full prescription details on hover if label is truncated.",
            "dependencies": [
              11,
              12
            ],
            "details": "For long medication names, Chart.js may truncate legend labels. Add legend.labels.generateLabels callback or title plugin to show full details (name, dose, frequency, half-life) on hover. This improves UX for prescriptions with long names.",
            "status": "pending",
            "testStrategy": "Add prescription with 30+ character name, verify hover shows full details even if legend text is truncated.",
            "parentId": "undefined"
          },
          {
            "id": 17,
            "title": "Style legend for better visual hierarchy",
            "description": "Enhance legend styling with better spacing, font sizing, and visual separation from the chart area.",
            "dependencies": [
              11
            ],
            "details": "Adjust legend.labels config: increase font.size to 12-14px, add boxWidth for color swatch sizing, consider adding border or background to legend area for visual separation. Test readability on different screen sizes.",
            "status": "pending",
            "testStrategy": "Visual inspection on desktop and mobile viewports. Verify legend is readable and doesn't overlap with chart area.",
            "parentId": "undefined"
          },
          {
            "id": 18,
            "title": "Handle legend overflow for many medications",
            "description": "Implement scrollable or wrapped legend layout when many prescriptions are displayed simultaneously.",
            "dependencies": [
              11,
              14
            ],
            "details": "With 5+ medications, legend may overflow or wrap poorly. Configure Chart.js legend maxHeight and overflow behavior, or implement custom HTML legend with scrollable container. Test with 8-10 simultaneous prescriptions.",
            "status": "pending",
            "testStrategy": "Add 8-10 prescriptions to compare mode, verify legend remains usable without overlapping chart or causing layout issues.",
            "parentId": "undefined"
          },
          {
            "id": 19,
            "title": "Add accessibility attributes to legend",
            "description": "Ensure legend is accessible with proper ARIA labels and keyboard navigation support.",
            "dependencies": [
              11,
              13
            ],
            "details": "Chart.js canvas-based legends have limited accessibility. Consider: adding aria-label to chart container describing medications shown, implementing keyboard focus for legend toggle, or adding screen-reader-friendly text summary of displayed medications.",
            "status": "pending",
            "testStrategy": "Test with screen reader (VoiceOver/NVDA). Verify medications can be identified. Test keyboard navigation of legend toggle.",
            "parentId": "undefined"
          },
          {
            "id": 20,
            "title": "Document legend functionality in user guide",
            "description": "Add documentation explaining legend features including click-to-toggle, color coding, and label format.",
            "dependencies": [
              11,
              12,
              13
            ],
            "details": "Update any existing user documentation or add inline help explaining: legend shows medication name/dose/frequency, colors correspond to graph curves, clicking legend items toggles visibility, useful for comparing specific medications.",
            "status": "pending",
            "testStrategy": "Review documentation for accuracy. Have a new user test feature discoverability using only the documentation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "GraphViewer.vue already has Chart.js legend configured at lines 116-120 (display: true, position: 'top', usePointStyle: true, padding: 16). Legend shows dataset labels which come from GraphDataset.label property. getGraphData in multiDose.ts line 131 already sets label to prescription name + frequency. Verify legend is working correctly and enhance if needed: add dose to label format, ensure colors match curves, add interactive click-to-toggle visibility. May only need minor label formatting changes.",
        "updatedAt": "2026-02-14T22:32:51.352Z"
      },
      {
        "id": "12",
        "title": "Make graph downloadable as image",
        "description": "Users need to be able to download the generated graph as an image file (PNG or similar format) for sharing or documentation purposes.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Image Export Utility Module",
            "description": "Create a new utility module `src/core/export/imageExport.ts` that provides functions for converting canvas elements to downloadable image files using the native Canvas API and Chart.js toBase64Image method.",
            "dependencies": [],
            "details": "Create `src/core/export/imageExport.ts` with: 1) `canvasToDataURL(canvas: HTMLCanvasElement, format?: 'png' | 'jpeg', quality?: number): string` - wrapper for canvas.toDataURL(). 2) `downloadImage(dataURL: string, filename: string): void` - creates an anchor element, sets href to dataURL, download attribute to filename, and programmatically clicks to trigger download. 3) `generateFilename(prescriptionName: string, timestamp?: boolean): string` - creates sanitized filename like 'Drug-Name-PK-Curve-2024-01-15.png'. Handle special characters and spaces in drug names by replacing with hyphens.",
            "status": "pending",
            "testStrategy": "Create `src/core/export/__tests__/imageExport.spec.ts`: 1) Test canvasToDataURL returns valid data URL string starting with 'data:image/png'. 2) Test downloadImage creates and clicks anchor element (mock document.createElement). 3) Test generateFilename sanitizes special characters, handles timestamps, and includes proper extension.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Expose Chart Instance Reference from GraphViewer",
            "description": "Modify GraphViewer.vue to expose the Chart.js instance via defineExpose() so parent components can access the chart's toBase64Image() method for high-quality exports.",
            "dependencies": [
              1
            ],
            "details": "In `src/components/GraphViewer.vue`: 1) Add `defineExpose({ getChartInstance: () => chartInstance, getCanvas: () => canvasRef.value })`. 2) Create a method `exportToImage(format: 'png' | 'jpeg' = 'png', quality = 1.0): string | null` that calls `chartInstance?.toBase64Image('image/png', quality)` and returns the data URL. 3) Expose this method via defineExpose. This allows App.vue to call the export method directly without duplicating canvas logic.",
            "status": "pending",
            "testStrategy": "Add tests to `src/components/__tests__/GraphViewer.spec.ts`: 1) Test that getChartInstance returns the chart instance when datasets exist. 2) Test that getCanvas returns the canvas element reference. 3) Test exportToImage returns null when no chart exists (empty datasets).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Download Button UI to GraphViewer Component",
            "description": "Add a 'Download as PNG' button within the GraphViewer component template, positioned appropriately near the chart with consistent styling matching existing buttons.",
            "dependencies": [
              2
            ],
            "details": "In `src/components/GraphViewer.vue` template: 1) Add a button element with class 'download-btn' positioned above or below the chart (consider placing in a toolbar div alongside disclaimer). 2) Button text: 'Download PNG' with an optional download icon (using Unicode ⬇ or inline SVG). 3) Add scoped CSS matching the existing app button styles (.btn-primary pattern from App.vue): blue background, white text, hover state, 0.75rem 1.5rem padding. 4) Button should only be visible when datasets.length > 0.",
            "status": "pending",
            "testStrategy": "Add tests to GraphViewer.spec.ts: 1) Test download button is NOT rendered when datasets is empty. 2) Test download button IS rendered when datasets has items. 3) Test button has correct class and text content.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Download Button Click Handler",
            "description": "Wire up the download button click event to trigger the image export using the exposed exportToImage method and downloadImage utility, generating an appropriate filename from the current prescription data.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "In `src/components/GraphViewer.vue`: 1) Import `downloadImage` and `generateFilename` from `@/core/export/imageExport`. 2) Create `handleDownload()` function that: a) Gets data URL via `exportToImage('png')`, b) If datasets.length > 0, uses first dataset label for filename via generateFilename, c) Calls downloadImage with data URL and generated filename. 3) Bind @click='handleDownload' to the download button. 4) If multiple datasets, join labels with '-and-' in filename (e.g., 'DrugA-and-DrugB-PK-Curve.png').",
            "status": "pending",
            "testStrategy": "Add tests: 1) Mock downloadImage and verify it's called with correct arguments when button clicked. 2) Test filename generation includes first dataset label. 3) Test multi-dataset filename concatenation. 4) Test no action taken if exportToImage returns null.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Loading State During Export",
            "description": "Implement a brief loading indicator on the download button during the export process to provide user feedback, especially for large/complex charts.",
            "dependencies": [
              4
            ],
            "details": "In GraphViewer.vue: 1) Add `isExporting = ref(false)` state. 2) Modify handleDownload to set isExporting=true at start, then false after download completes. 3) Conditionally show 'Exporting...' text or spinner icon when isExporting is true. 4) Disable button (`:disabled='isExporting'`) during export to prevent double-clicks. 5) Add appropriate CSS for disabled state (opacity: 0.6, cursor: not-allowed).",
            "status": "pending",
            "testStrategy": "Test: 1) Button is disabled while isExporting is true. 2) Button shows 'Exporting...' text during export. 3) Button returns to normal state after export completes.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add JPEG Format Support with Quality Option",
            "description": "Extend the export functionality to support JPEG format in addition to PNG, giving users a choice for smaller file sizes when transparency isn't needed.",
            "dependencies": [
              4
            ],
            "details": "1) Update imageExport.ts to handle 'jpeg' format with configurable quality (0.0-1.0). 2) In GraphViewer.vue, add a format selector (small dropdown or toggle) near the download button: PNG (default, lossless) or JPEG (smaller, 0.92 quality). 3) Store selected format in `exportFormat = ref<'png' | 'jpeg'>('png')`. 4) Pass format to exportToImage call. 5) For JPEG, set white background on canvas before export (Chart.js charts have transparent background by default which shows as black in JPEG).",
            "status": "pending",
            "testStrategy": "Test: 1) PNG export produces data URL starting with 'data:image/png'. 2) JPEG export produces data URL starting with 'data:image/jpeg'. 3) Format selector changes the exported format. 4) JPEG with transparent chart still produces valid image (white background).",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Handle White Background for JPEG Export",
            "description": "Implement background fill logic to ensure JPEG exports have a white background instead of black (which occurs when converting transparent PNG to JPEG).",
            "dependencies": [
              6
            ],
            "details": "In imageExport.ts or GraphViewer.vue export logic: 1) For JPEG format, before calling toBase64Image, create temporary canvas same size as chart canvas. 2) Fill temp canvas with white (#FFFFFF). 3) Draw original chart canvas onto temp canvas. 4) Export temp canvas as JPEG. Alternative approach: Configure Chart.js with plugins.backgroundColor = '#FFFFFF' option during export. This ensures JPEG exports don't have black backgrounds where chart is transparent.",
            "status": "pending",
            "testStrategy": "Visual test: Export same chart as PNG and JPEG, verify JPEG has white background not black. Unit test: Mock canvas context and verify fillRect called with white color before drawImage for JPEG exports.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Add Prescription Metadata Overlay to Exported Image",
            "description": "Optionally include prescription details (drug name, dosage, frequency) as a text overlay or footer in the exported image for documentation purposes.",
            "dependencies": [
              4
            ],
            "details": "1) Add checkbox option 'Include prescription details' near download button. 2) Create `addMetadataToCanvas(canvas: HTMLCanvasElement, prescriptions: Prescription[]): HTMLCanvasElement` function that: a) Creates a new canvas taller than original (add 60px footer), b) Draws original chart, c) Adds text below with drug name, dose, frequency, and disclaimer. 3) Use canvas 2D context `fillText()` with readable font (14px sans-serif). 4) Include small 'Educational use only' watermark. 5) Store preference in localStorage for persistence.",
            "status": "pending",
            "testStrategy": "Test: 1) Without metadata, exported image matches original canvas dimensions. 2) With metadata enabled, canvas height increases. 3) Metadata text includes drug name and dosage info. 4) Preference persists in localStorage.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Integrate Download Feature with App.vue Actions",
            "description": "Add download functionality to the graph-section actions in App.vue alongside existing Save and New Prescription buttons for consistent UX placement.",
            "dependencies": [
              4
            ],
            "details": "In `src/App.vue`: 1) Add template ref to GraphViewer: `<GraphViewer ref='graphViewerRef' ...>`. 2) Get ref: `const graphViewerRef = ref<InstanceType<typeof GraphViewer> | null>(null)`. 3) Add 'Download Graph' button in .actions div with btn-secondary styling. 4) Create handleDownloadGraph() that calls `graphViewerRef.value?.handleDownload()`. 5) This provides an alternative download location (in actions bar) in addition to the button on GraphViewer itself, giving users two access points.",
            "status": "pending",
            "testStrategy": "Integration test: 1) Verify GraphViewer ref is accessible from App.vue. 2) Test clicking App.vue download button triggers GraphViewer's handleDownload. 3) Test button only appears when showGraph is true.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Add Accessibility and Keyboard Support for Download",
            "description": "Ensure the download functionality is fully accessible with proper ARIA attributes, keyboard navigation, and screen reader support.",
            "dependencies": [
              3,
              4
            ],
            "details": "1) Add `aria-label='Download pharmacokinetic curve as PNG image'` to download button. 2) Ensure button is focusable and activatable via Enter/Space keys (native button behavior). 3) Add `role='button'` if using non-button element. 4) Add screen reader announcement after successful download using aria-live region: 'Graph downloaded successfully'. 5) Add `title` attribute with tooltip text explaining the download feature. 6) Ensure loading state is announced: 'Preparing download'. 7) Test with keyboard-only navigation.",
            "status": "pending",
            "testStrategy": "Test: 1) Button has correct aria-label attribute. 2) Button can be triggered with keyboard (Enter key). 3) Screen reader announcement element exists and updates on download. 4) No focus trap issues during export process.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Create image export utility module",
            "description": "Create src/core/export/imageExport.ts with canvasToDataURL wrapper and downloadImage function using anchor element click pattern for browser-triggered downloads.",
            "dependencies": [],
            "details": "Create new directory src/core/export/ and imageExport.ts file with two pure functions: (1) canvasToDataURL(canvas: HTMLCanvasElement, type: string = 'image/png', quality?: number): string - wraps canvas.toDataURL with error handling, (2) downloadImage(dataUrl: string, filename: string): void - creates temporary anchor element with href=dataUrl and download=filename, triggers click, then removes anchor. Export both functions for reuse.",
            "status": "pending",
            "testStrategy": "Create src/core/export/__tests__/imageExport.spec.ts testing: (1) canvasToDataURL returns valid data URL string starting with 'data:image/png', (2) downloadImage creates anchor element with correct attributes, (3) downloadImage triggers click event on anchor, (4) anchor is removed from DOM after click.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Create barrel export for export module",
            "description": "Create src/core/export/index.ts barrel file to export imageExport functions following existing codebase patterns.",
            "dependencies": [
              11
            ],
            "details": "Create src/core/export/index.ts with: export { canvasToDataURL, downloadImage } from './imageExport'. Follow the same barrel pattern used in src/core/models/index.ts and src/core/storage/index.ts for consistency.",
            "status": "pending",
            "testStrategy": "Verify imports work correctly via TypeScript compilation and test file imports.",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Expose Chart instance via defineExpose in GraphViewer",
            "description": "Add defineExpose to GraphViewer.vue to expose the Chart.js instance reference for parent components to access toBase64Image() method.",
            "dependencies": [],
            "details": "In GraphViewer.vue after the script setup section, add defineExpose({ getChartInstance: () => chartInstance }) to expose a getter function that returns the current Chart.js instance. Using a getter rather than the raw ref ensures the latest instance is returned even after chart re-renders. The Chart.js instance provides toBase64Image() method which returns PNG data URL.",
            "status": "pending",
            "testStrategy": "Add test in GraphViewer.spec.ts verifying: (1) exposed getChartInstance returns Chart instance after mount, (2) getChartInstance returns null when no datasets, (3) returned instance has toBase64Image method available.",
            "parentId": "undefined"
          },
          {
            "id": 14,
            "title": "Create export options interface",
            "description": "Define TypeScript interface for image export options including filename prefix, format type, and optional scale factor.",
            "dependencies": [
              11
            ],
            "details": "Add to src/core/export/imageExport.ts: interface ExportOptions { filenamePrefix?: string; format?: 'png'; scale?: number; }. For MVP only PNG format is needed. Scale option allows high-DPI export (default 1). Add helper function generateFilename(prefix: string): string that creates timestamped filename like 'pk-graph-2024-01-15-1430.png'.",
            "status": "pending",
            "testStrategy": "Test generateFilename produces valid filename with timestamp pattern, test default values in ExportOptions work correctly.",
            "parentId": "undefined"
          },
          {
            "id": 15,
            "title": "Implement exportChartAsImage utility function",
            "description": "Create main export function that takes Chart instance and options, extracts image data using toBase64Image(), and triggers download.",
            "dependencies": [
              11,
              14
            ],
            "details": "Add to src/core/export/imageExport.ts: export function exportChartAsImage(chart: Chart, options?: ExportOptions): void. Implementation: (1) call chart.toBase64Image('image/png', 1) to get data URL, (2) generate filename using generateFilename(options?.filenamePrefix || 'pk-graph'), (3) call downloadImage(dataUrl, filename). This function is synchronous since Chart.js toBase64Image is synchronous.",
            "status": "pending",
            "testStrategy": "Test with mock Chart instance that has toBase64Image method, verify downloadImage is called with correct data URL and filename format.",
            "parentId": "undefined"
          },
          {
            "id": 16,
            "title": "Add Download PNG button to GraphViewer template",
            "description": "Add a download button to GraphViewer.vue template that triggers PNG export when clicked.",
            "dependencies": [
              13,
              15
            ],
            "details": "Add button in GraphViewer template after the disclaimer div: <button class=\"download-btn\" @click=\"handleDownload\" :disabled=\"!hasChart\">Download PNG</button>. Add computed hasChart = computed(() => chartInstance !== null). Add handleDownload method that imports exportChartAsImage and calls it with chartInstance. Add CSS styling for download-btn matching existing component styles.",
            "status": "pending",
            "testStrategy": "Test button renders, test button is disabled when no chart data, test click triggers export function with correct parameters.",
            "parentId": "undefined"
          },
          {
            "id": 17,
            "title": "Add accessibility attributes to download button",
            "description": "Add ARIA attributes and keyboard support to the download button for accessibility compliance.",
            "dependencies": [
              16
            ],
            "details": "Update button in GraphViewer: aria-label=\"Download graph as PNG image\", role=\"button\", and ensure button is keyboard-focusable (native button element handles this). Add aria-disabled=\"true\" when hasChart is false. Consider adding sr-only text explaining the action for screen readers.",
            "status": "pending",
            "testStrategy": "Test aria-label is present, test aria-disabled matches disabled state, test button is keyboard-accessible with Tab navigation.",
            "parentId": "undefined"
          },
          {
            "id": 18,
            "title": "Add visual feedback during export",
            "description": "Add brief visual indication when download is triggered, even though toBase64Image is synchronous.",
            "dependencies": [
              16
            ],
            "details": "Add ref isExporting = ref(false). In handleDownload: set isExporting true, call export, use nextTick or setTimeout(0) to allow UI update, then set false. Update button to show 'Downloading...' text when isExporting is true. This provides user feedback especially on slower devices or large charts. Add :class=\"{ 'downloading': isExporting }\" for CSS animation.",
            "status": "pending",
            "testStrategy": "Test isExporting toggles during export process, test button text changes during export state.",
            "parentId": "undefined"
          },
          {
            "id": 19,
            "title": "Add error handling for export failures",
            "description": "Handle edge cases where export might fail, such as missing chart instance or browser restrictions.",
            "dependencies": [
              15,
              16
            ],
            "details": "Wrap export logic in try-catch in handleDownload. If chartInstance is null, show console warning and return early. If toBase64Image throws (rare), catch error and optionally emit error event or show user message. Add emit defineEmits<{ exportError: [error: Error] }>() for parent component notification. Log errors to console for debugging.",
            "status": "pending",
            "testStrategy": "Test null chart instance case returns gracefully, test error during export is caught and logged, test exportError event is emitted on failure.",
            "parentId": "undefined"
          },
          {
            "id": 20,
            "title": "Write comprehensive tests for image export feature",
            "description": "Create complete test suite covering all export functionality including edge cases and integration with GraphViewer.",
            "dependencies": [
              11,
              13,
              15,
              16,
              19
            ],
            "details": "Create/update test files: (1) src/core/export/__tests__/imageExport.spec.ts - unit tests for all export utilities, (2) Update src/components/__tests__/GraphViewer.spec.ts - integration tests for download button, exposed chart instance, and export flow. Use vitest mocks for document.createElement, anchor.click, Chart.toBase64Image. Test scenarios: successful export, empty chart, error recovery, filename generation.",
            "status": "pending",
            "testStrategy": "Run npm run test to verify all new tests pass. Aim for 100% coverage of new export code. Test both happy path and error conditions.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: (1) Create image export utility module src/core/export/imageExport.ts with canvasToDataURL wrapper and downloadImage function using anchor element click pattern, (2) Expose Chart instance from GraphViewer via defineExpose - Chart.js has built-in toBase64Image() method, (3) Add Download PNG button to GraphViewer template with click handler calling export utility, (4) Add accessibility attributes and loading state during export. Chart.js toBase64Image is synchronous so loading state is simple.",
        "updatedAt": "2026-02-14T21:25:31.158Z"
      },
      {
        "id": "13",
        "title": "Fix prescription import - JSON submission not working",
        "description": "The import dialog opens but when users enter JSON and try to submit, nothing happens and they're returned to the medication form. Investigation and fix needed.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add console logging to trace import event flow",
            "description": "Add debugging console.log statements at each step of the import flow to verify where events are being lost",
            "dependencies": [],
            "details": "Add console.log in ImportPrescriptions.handleImport() before/after savePrescription calls, in emit('imported'), in PrescriptionForm.handleImportSuccess(), and add a temporary @imported listener in App.vue. This establishes a diagnostic baseline before making fixes.",
            "status": "pending",
            "testStrategy": "Run app in browser, open console, paste valid JSON and submit. Verify each log statement fires in expected sequence.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Verify savePrescription actually persists data",
            "description": "Check browser localStorage after import to confirm prescriptions are being saved correctly by savePrescription()",
            "dependencies": [
              1
            ],
            "details": "Open browser DevTools > Application > Local Storage after importing prescriptions. Check that the key for prescriptions contains the imported data. Also verify savePrescription() in prescriptionStorage.ts correctly generates IDs and stores to localStorage.",
            "status": "pending",
            "testStrategy": "Manual browser testing: import JSON with 2 prescriptions, check localStorage contains both with valid IDs.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add emitted event from PrescriptionForm to App.vue",
            "description": "PrescriptionForm needs to bubble up the 'imported' event so App.vue can react to prescription imports",
            "dependencies": [
              1,
              2
            ],
            "details": "In PrescriptionForm.vue: 1) Add 'imported' to defineEmits, 2) Modify handleImportSuccess to emit('imported', count) after closing modal. In App.vue: 3) Add @imported handler to PrescriptionForm component, 4) Handler should refresh savedPrescriptions from getAllPrescriptions().",
            "status": "pending",
            "testStrategy": "Unit test: mock emit in PrescriptionForm, verify @imported fires. Integration test: import prescription, verify savedPrescriptions ref updates.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Fix handleImportSuccess to receive and forward count parameter",
            "description": "handleImportSuccess() in PrescriptionForm currently ignores the count parameter from ImportPrescriptions",
            "dependencies": [
              3
            ],
            "details": "Change handleImportSuccess() signature from 'function handleImportSuccess()' to 'function handleImportSuccess(count: number)'. Then emit('imported', count) to pass the count up to App.vue for potential display in a toast/notification.",
            "status": "pending",
            "testStrategy": "Verify the count is correctly passed from ImportPrescriptions through PrescriptionForm to App.vue handler.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add success feedback after import",
            "description": "Users need visual confirmation that import succeeded - currently modal just closes silently",
            "dependencies": [
              3,
              4
            ],
            "details": "Options: 1) Keep modal open longer to show success message (already implemented in ImportPrescriptions but user may close too quickly), 2) Add a toast/notification in App.vue when imported event fires, 3) Show count of imported prescriptions in a dismissible banner. Implement option 2 or 3 for better UX.",
            "status": "pending",
            "testStrategy": "Import prescriptions, verify success message appears and displays correct count. Verify it auto-dismisses or can be closed.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add navigation to view saved prescriptions after import",
            "description": "After successful import, users have no way to see or select imported prescriptions since PrescriptionList isn't implemented",
            "dependencies": [
              5
            ],
            "details": "This is blocked by Task 9 (PrescriptionList component). For now, either: 1) Add temporary list of saved prescriptions in App.vue, 2) Add 'View Saved' button that shows localStorage contents in an alert, 3) Document that viewing imports requires Task 9 completion. Choose option 3 and add TODO comment.",
            "status": "pending",
            "testStrategy": "Document limitation in code comments. Verify import saves correctly (via DevTools) even if viewing isn't implemented yet.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Add validation error display for import failures",
            "description": "When JSON is invalid or prescriptions fail validation, errors are shown but may be missed by users",
            "dependencies": [
              1
            ],
            "details": "Review ImportPrescriptions.vue result display (lines 121-136). Ensure: 1) Error container is visible and prominent, 2) Validation errors from validatePrescription() are clearly shown, 3) User cannot close modal accidentally while errors are displayed. Consider adding a 'Copy errors' button for debugging.",
            "status": "pending",
            "testStrategy": "Test with invalid JSON (syntax error), valid JSON with invalid prescription data (e.g., negative halfLife), and mixed valid/invalid prescriptions.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Write unit tests for ImportPrescriptions component",
            "description": "Create comprehensive test coverage for the import component to prevent regressions",
            "dependencies": [
              3,
              4,
              7
            ],
            "details": "Create src/components/__tests__/ImportPrescriptions.spec.ts with tests for: 1) isValidJson computed property, 2) handleImport with valid single prescription, 3) handleImport with array format, 4) handleImport with prescriptions wrapper object, 5) Validation failures properly counted and displayed, 6) emit('imported') called with correct count, 7) emit('close') called on cancel.",
            "status": "pending",
            "testStrategy": "Run npm run test -- ImportPrescriptions.spec.ts. Target 90%+ line coverage on the component.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Test full import workflow end-to-end",
            "description": "Manual end-to-end testing of the complete import flow after all fixes are applied",
            "dependencies": [
              3,
              4,
              5,
              6,
              7,
              8
            ],
            "details": "Test scenarios: 1) Import single valid prescription JSON, 2) Import array of 3 prescriptions, 3) Import with prescriptions wrapper object, 4) Import partially invalid data (2 valid, 1 invalid), 5) Import completely invalid JSON, 6) Verify localStorage after each test, 7) Verify UI feedback after each test.",
            "status": "pending",
            "testStrategy": "Create test JSON fixtures for each scenario. Document expected vs actual behavior in a testing checklist.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Remove debug logging and clean up implementation",
            "description": "Remove temporary console.log statements added during debugging and finalize the fix",
            "dependencies": [
              9
            ],
            "details": "Remove all console.log statements added in subtask 1. Review all changes for code quality (consistent naming, proper TypeScript types, no unused variables). Run npm run lint and npm run type-check. Update any relevant documentation or comments.",
            "status": "pending",
            "testStrategy": "Run npm run lint, npm run type-check, npm run test. Verify no console.log statements remain in production code (grep for console.log).",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Debug task - investigate ImportPrescriptions.vue component. The component exists at src/components/ImportPrescriptions.vue and is mounted by PrescriptionForm when showImportModal=true. handleImport() parses JSON, validates via validatePrescription(), calls savePrescription(). handleImportSuccess in PrescriptionForm just closes modal. Likely issues: (1) Event emission - @imported fires but parent doesn't refresh graph view, (2) Form doesn't reload to show imported data, (3) Possible validation errors silently failing. Need to trace event flow and add debugging.",
        "updatedAt": "2026-02-14T22:29:55.153Z"
      },
      {
        "id": "14",
        "title": "Add metabolite graphing capability",
        "description": "Users need to be able to graph associated metabolite information alongside medication curves to see how metabolite levels change over time.",
        "details": "",
        "testStrategy": "",
        "status": "in-progress",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Research metabolite pharmacokinetic equations and model requirements",
            "description": "Research the standard pharmacokinetic model for metabolite concentration curves, including parent-metabolite conversion kinetics.",
            "dependencies": [],
            "details": "Research one-compartment metabolite kinetics where metabolite formation rate equals parent drug elimination multiplied by fraction converted (fm). Standard equation: C_met(t) = Dose * fm * (ke_parent/(ke_met - ke_parent)) * (e^(-ke_parent*t) - e^(-ke_met*t)). Document required parameters: metaboliteConversionFraction (fm, 0-1), metaboliteHalfLife. Note edge case when ke_met ≈ ke_parent requires fallback formula similar to ka≈ke case.",
            "status": "pending",
            "testStrategy": "Create a reference document summarizing equations with worked examples from pharmacology textbooks. Verify equation produces expected curve shapes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Extend Prescription interface with metabolite parameters",
            "description": "Add metaboliteConversionFraction and update metaboliteHalfLife usage in the Prescription interface and types.",
            "dependencies": [
              1
            ],
            "details": "In src/core/models/prescription.ts: Add metaboliteConversionFraction?: number (range 0-1, fraction of parent converted to metabolite, defaults undefined meaning no metabolite). Keep existing metaboliteLife?: number field, rename to metaboliteHalfLife for clarity via deprecation alias. Add MetaboliteParams interface for grouping. Update TimeSeriesPoint or create MetaboliteTimeSeriesPoint if needed.",
            "status": "pending",
            "testStrategy": "Unit tests for type compatibility. Verify existing prescriptions without metabolite params still pass validation.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add validation rules for metabolite parameters",
            "description": "Implement validation for metaboliteConversionFraction and metaboliteHalfLife with appropriate ranges and cross-field checks.",
            "dependencies": [
              2
            ],
            "details": "In src/core/models/prescription.ts: Add VALIDATION_RULES entries for metaboliteConversionFraction (min: 0, max: 1) and metaboliteHalfLife (min: 0.1, max: 1000 per existing metaboliteLife rules). Add cross-field validation: if one metabolite param is set, both should be set (warn if not). Add warning if metaboliteHalfLife is much shorter than parent halfLife (may indicate modeling error).",
            "status": "pending",
            "testStrategy": "Unit tests for validatePrescription() covering: valid metabolite params, missing one param warning, out-of-range values. Test edge cases like fm=0 and fm=1.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement calculateMetaboliteConcentration in pkCalculator.ts",
            "description": "Create pure function for metabolite concentration at a given time using one-compartment metabolite kinetics.",
            "dependencies": [
              1,
              2
            ],
            "details": "In src/core/calculations/pkCalculator.ts: Export calculateMetaboliteConcentration(time, dose, parentHalfLife, metaboliteHalfLife, conversionFraction). Implement: C_met(t) = Dose * fm * (ke_p/(ke_m - ke_p)) * (exp(-ke_p*t) - exp(-ke_m*t)). Add fallback formula when |ke_m - ke_p| < tolerance: C_met(t) ≈ Dose * fm * ke_p * t * exp(-ke_p*t). Handle edge cases: time <= 0, dose <= 0, fm = 0.",
            "status": "pending",
            "testStrategy": "Unit tests with known-value reference cases: (1) Simple case matching hand-calculated values, (2) Edge case ke_m ≈ ke_p uses fallback, (3) fm=0 returns 0, (4) Verify curve peaks after parent drug peak.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement getMetabolitePeakTime helper function",
            "description": "Calculate time to peak metabolite concentration for display purposes.",
            "dependencies": [
              4
            ],
            "details": "In src/core/calculations/pkCalculator.ts: Export getMetabolitePeakTime(parentHalfLife, metaboliteHalfLife). Formula: Tmax_met = ln(ke_m/ke_p) / (ke_m - ke_p) when ke_m != ke_p, fallback to 1/ke_p when similar. Note metabolite peak always occurs after parent peak. Return 0 for edge cases per existing getPeakTime convention.",
            "status": "pending",
            "testStrategy": "Unit tests verifying: metabolite peak time > parent peak time, edge case ke_m ≈ ke_p uses fallback, compare against reference pharmacokinetic examples.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create accumulateMetaboliteDoses function in multiDose.ts",
            "description": "Calculate accumulated metabolite concentration curves from repeated parent drug dosing.",
            "dependencies": [
              4
            ],
            "details": "In src/core/calculations/multiDose.ts: Export accumulateMetaboliteDoses(prescription, startHours, endHours, intervalMinutes) returning TimeSeriesPoint[]. Follow same pattern as accumulateDoses: expand dose times, sum calculateMetaboliteConcentration contributions from all prior doses, normalize curve to peak=1.0. Guard: return empty array if metabolite params not defined on prescription.",
            "status": "pending",
            "testStrategy": "Unit tests: (1) Single dose metabolite curve matches calculateMetaboliteConcentration, (2) Multi-dose accumulation shows proper peak shifts, (3) Returns empty for prescription without metabolite params.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Extend GraphDataset and getGraphData for metabolite curves",
            "description": "Update getGraphData to optionally return metabolite datasets alongside parent drug datasets.",
            "dependencies": [
              6
            ],
            "details": "In src/core/calculations/multiDose.ts and src/core/models/prescription.ts: Add optional isMetabolite: boolean to GraphDataset interface. Update getGraphData to accept optional includeMetabolites: boolean parameter. When true and prescription has metabolite params, generate additional dataset with label 'name (metabolite)', same base color with dashed line styling flag, and metabolite curve data from accumulateMetaboliteDoses.",
            "status": "pending",
            "testStrategy": "Unit tests: (1) includeMetabolites=false returns only parent curves, (2) includeMetabolites=true adds metabolite datasets with isMetabolite flag, (3) Prescriptions without metabolite params excluded from metabolite datasets.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Update PrescriptionForm with metabolite input fields",
            "description": "Add optional metabolite parameter inputs to the prescription form UI.",
            "dependencies": [
              3
            ],
            "details": "In src/components/PrescriptionForm.vue: Add collapsible 'Metabolite Parameters (Optional)' section. Include metaboliteConversionFraction number input (0-1, step 0.01, placeholder 'Fraction converted to metabolite') and metaboliteHalfLife number input (hours, same validation as existing fields). Display validation warnings for metabolite params. Ensure form continues working without metabolite inputs for basic use case.",
            "status": "pending",
            "testStrategy": "Component tests: (1) Form renders without metabolite section expanded, (2) Metabolite inputs accept valid values, (3) Validation errors display for invalid values, (4) Submit emits prescription with metabolite params when provided.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Update GraphViewer to render metabolite curves with distinct styling",
            "description": "Modify GraphViewer to display metabolite curves with dashed lines alongside parent drug curves.",
            "dependencies": [
              7
            ],
            "details": "In src/components/GraphViewer.vue: Detect isMetabolite flag on GraphDataset. For metabolite datasets, apply Chart.js borderDash property (e.g., [5, 5]) for dashed line styling. Use same base color as parent but potentially with reduced opacity. Update legend to clearly distinguish metabolite curves (e.g., 'Drug A (metabolite)'). Ensure metabolite curves render on same scale as parent.",
            "status": "pending",
            "testStrategy": "Component tests: (1) Metabolite datasets render with dashed line, (2) Legend shows correct labels, (3) Both parent and metabolite curves visible on same graph. Manual visual testing for appearance.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Add toggle control for metabolite curve visibility in App.vue",
            "description": "Implement UI control to show/hide metabolite curves and integrate metabolite graphing across the application.",
            "dependencies": [
              8,
              9
            ],
            "details": "In src/App.vue: Add 'Show Metabolites' checkbox/toggle near graph controls. Pass includeMetabolites boolean to getGraphData calls. Persist preference in localStorage. Update GraphViewer props if needed for toggle state. Ensure toggle only appears when at least one prescription has metabolite params defined. Add integration tests for full flow: enter prescription with metabolite params → enable toggle → verify both curves display.",
            "status": "pending",
            "testStrategy": "Integration tests: (1) Toggle hidden when no prescriptions have metabolite params, (2) Toggle visible and functional when metabolite params exist, (3) Graph updates when toggle changed, (4) Preference persists across page reload.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: (1) Research pharmacokinetic model for metabolite curves - typically requires parent-metabolite conversion rate and metabolite elimination rate, CLAUDE.md notes metaboliteLife is 'informational only' currently, (2) Extend Prescription interface with metabolite parameters (metaboliteConversionRate, metaboliteHalfLife), (3) Implement metabolite concentration calculation in pkCalculator.ts - standard approach is compartmental model where metabolite formation rate equals parent elimination, (4) Update multiDose.ts accumulateDoses to optionally return metabolite TimeSeriesPoint array, (5) Modify GraphViewer to plot metabolite curves with distinct styling (dashed line) alongside parent drug curves.",
        "updatedAt": "2026-02-15T11:20:46.856Z"
      },
      {
        "id": "15",
        "title": "Auto-extend graph timeframe past maximum medication time",
        "description": "Graph timeframe should automatically extend a few hours past the maximum estimated time for all medications being tracked to show tail-off behavior.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create utility function to calculate last dose time from prescription",
            "description": "Implement a helper function that calculates the latest dose administration time for a given prescription within the simulation window.",
            "dependencies": [],
            "details": "Create a function getLastDoseTime(prescription: Prescription, numDays: number) in multiDose.ts (or a new timeframe utility file). This function uses expandDoseTimes() to get all dose times and returns the maximum value. This provides the base time from which tail-off buffer is calculated.",
            "status": "pending",
            "testStrategy": "Unit test with prescriptions having different frequencies (once, bid, qid) and verify the correct last dose time is returned for various numDays values.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create utility function to calculate required tail-off duration",
            "description": "Implement a helper function that calculates how many hours past the last dose are needed to show adequate tail-off behavior based on half-life.",
            "dependencies": [],
            "details": "Create calculateTailOffDuration(halfLife: number, decayFactor: number = 5) that returns halfLife * decayFactor. The default factor of 5 gives ~97% elimination (5 half-lives = 3.125% remaining). Export from calculations module for reuse.",
            "status": "pending",
            "testStrategy": "Unit test with various half-lives: 6hr × 5 = 30hr, 24hr × 5 = 120hr. Verify configurable decay factor works correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create computed property for auto-calculated end time in App.vue",
            "description": "Add a computed property that calculates the recommended end time based on prescription parameters and tail-off requirements.",
            "dependencies": [
              1,
              2
            ],
            "details": "In App.vue, create autoEndHours computed that: (1) returns default 48 if no currentPrescription, (2) calculates lastDoseTime + tailOffDuration using the helper functions, (3) applies minimum floor (e.g., 24 hours) and maximum cap (168 hours/1 week). Import the utility functions from calculations module.",
            "status": "pending",
            "testStrategy": "Component test verifying autoEndHours returns correct values for prescriptions with short vs long half-lives, and respects min/max caps.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add toggle for auto vs manual timeframe mode",
            "description": "Add state to track whether user wants automatic timeframe extension or manual slider control.",
            "dependencies": [],
            "details": "Add useAutoTimeframe ref (default true) to App.vue state section. When true, the graph uses autoEndHours; when false, uses the manual endHours slider value. This preserves user control while enabling smart defaults.",
            "status": "pending",
            "testStrategy": "Verify toggle state persists and correctly switches between auto and manual modes.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create effectiveEndHours computed combining auto and manual modes",
            "description": "Add computed property that returns either autoEndHours or manual endHours based on toggle state.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create effectiveEndHours computed: return useAutoTimeframe.value ? autoEndHours.value : endHours.value. Update graphDatasets computed to use effectiveEndHours instead of endHours. Update GraphViewer :end-hours prop binding.",
            "status": "pending",
            "testStrategy": "Test that effectiveEndHours returns auto value when toggle is true, manual value when false.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Update graph controls UI for auto/manual toggle",
            "description": "Modify the graph-controls section to include a checkbox/toggle for auto timeframe mode and conditionally show the slider.",
            "dependencies": [
              4,
              5
            ],
            "details": "In template, add checkbox input bound to useAutoTimeframe with label 'Auto-extend timeframe'. Update slider label to show effectiveEndHours value. Optionally disable or hide slider when auto mode is active to reduce confusion.",
            "status": "pending",
            "testStrategy": "Visual testing: verify checkbox toggles auto mode, slider disabled/enabled state changes appropriately.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Handle edge case for prescriptions with very long half-lives",
            "description": "Ensure the auto-extension doesn't exceed reasonable limits and handles extreme half-life values gracefully.",
            "dependencies": [
              3
            ],
            "details": "In autoEndHours computed, cap result at 168 hours (1 week) maximum. Add validation: if calculated value exceeds cap, use cap. For very short simulations, ensure minimum of 24 hours or 2× first dose cycle. Log or display info when cap is applied.",
            "status": "pending",
            "testStrategy": "Test with half-life of 48hr (5×48=240hr should cap to 168hr) and half-life of 1hr (should use minimum floor).",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Support multiple prescriptions in auto-extension calculation",
            "description": "Extend auto-extension logic to handle future multi-prescription scenarios by finding max across all tracked medications.",
            "dependencies": [
              3
            ],
            "details": "Modify autoEndHours to support an array of prescriptions (for future multi-drug overlay feature). Use Math.max(...prescriptions.map(rx => lastDoseTime + tailOffDuration)) pattern. Currently works with single currentPrescription but architected for extensibility.",
            "status": "pending",
            "testStrategy": "Test with mock array of prescriptions having different half-lives; verify longest tail-off determines end time.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Update slider range to reflect effective timeframe",
            "description": "When in manual mode, sync the slider min/max to sensible values based on the prescription's characteristics.",
            "dependencies": [
              5,
              6
            ],
            "details": "Update slider min attribute to startHours or 12, and max to Math.max(168, autoEndHours) so user can manually extend beyond auto-calculated value if desired. Update step to appropriate granularity based on range.",
            "status": "pending",
            "testStrategy": "Verify slider range adjusts appropriately when switching between prescriptions with different characteristics.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Write integration tests for auto-extend feature",
            "description": "Create comprehensive tests verifying the complete auto-extend flow from prescription input to graph rendering.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "Create test file src/components/__tests__/AutoExtendTimeframe.spec.ts with tests: (1) auto mode calculates correct endHours, (2) manual override works, (3) switching prescriptions recalculates, (4) edge cases (very long/short half-lives) handled, (5) graph receives correct props.",
            "status": "pending",
            "testStrategy": "Integration tests using Vue Test Utils mounting App.vue, simulating prescription submission, verifying computed values and prop bindings.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Modify App.vue computed graphDatasets or add new computed that calculates max time across all prescriptions being graphed (max dose time + some multiple of longest half-life to show tail-off, e.g., 5× halfLife for 97% decay). Update endHours ref or create autoEndHours computed. GraphViewer already accepts endHours prop. May need to cap at reasonable maximum (e.g., 168 hours/1 week). Simple calculation: Math.max(...prescriptions.map(rx => lastDoseTime + 5*rx.halfLife)).",
        "updatedAt": "2026-02-15T00:27:35.698Z"
      },
      {
        "id": "16",
        "title": "Add timeframe input for medication duration",
        "description": "Users should be able to set the timeframe that medication has been taken, with input options for days or hours. This allows simulation of accumulation over custom durations.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend Prescription interface with duration fields",
            "description": "Add duration and durationUnit fields to the Prescription interface in prescription.ts to support custom timeframe input.",
            "dependencies": [],
            "details": "In src/core/models/prescription.ts, add two new optional fields to the Prescription interface: 'duration?: number' (the numeric value) and 'durationUnit?: 'days' | 'hours'' (the unit selector). These should be optional to maintain backward compatibility with existing stored prescriptions. Also add a DurationUnit type alias for 'days' | 'hours'.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compiles with new interface fields. Test that existing Prescription objects without duration fields remain valid.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add duration validation rules to VALIDATION_RULES",
            "description": "Define validation constraints for duration field including min/max values and unit-specific limits.",
            "dependencies": [
              1
            ],
            "details": "Add duration validation rules to VALIDATION_RULES constant in prescription.ts: duration must be positive (min: 0.1), max of 365 for days or 8760 for hours (1 year). Create a validateDuration() function following the pattern of existing validators (validateHalfLife, validatePeak). Should return errors for invalid values and warn for very long durations.",
            "status": "pending",
            "testStrategy": "Unit test validateDuration with edge cases: negative values, zero, extremely large values, boundary conditions for both days and hours units.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update validatePrescription to include duration validation",
            "description": "Integrate duration field validation into the main validatePrescription function with conditional logic for optional field.",
            "dependencies": [
              2
            ],
            "details": "Modify validatePrescription() in prescription.ts to call validateDuration() when duration is provided. Since duration is optional, validation should pass if duration is undefined. Add cross-field validation: if durationUnit is provided, duration must also be provided and vice versa.",
            "status": "pending",
            "testStrategy": "Test validatePrescription with prescriptions that have: no duration fields, valid duration/unit combo, duration without unit, unit without duration, invalid duration values.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add duration input field to PrescriptionForm",
            "description": "Create the numeric input field for duration in PrescriptionForm.vue with appropriate constraints and accessibility.",
            "dependencies": [
              1
            ],
            "details": "In PrescriptionForm.vue, add a new form-field div containing: label 'Medication Duration', number input bound to duration ref with min=0.1, step=0.5, and aria-describedby for hint text. Initialize duration ref with default value (7 days). Position after the metabolite half-life field in the form layout.",
            "status": "pending",
            "testStrategy": "Manual testing: verify input renders, accepts valid numbers, respects min constraint. Verify aria attributes are correct for accessibility.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add duration unit toggle to PrescriptionForm",
            "description": "Create a select dropdown or toggle button to switch between days and hours unit for duration input.",
            "dependencies": [
              4
            ],
            "details": "Add a select element next to the duration input with options 'days' and 'hours'. Use durationUnit ref initialized to 'days'. Style as inline-block or flex to appear side-by-side with duration input. Update field-hint to show appropriate range based on selected unit. Consider using a segmented button for cleaner UX.",
            "status": "pending",
            "testStrategy": "Manual testing: verify toggle switches units, hint text updates appropriately, form state correctly reflects both duration and durationUnit values.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Update PrescriptionForm computed prescription object",
            "description": "Include duration and durationUnit in the computed prescription object that gets emitted on form submit.",
            "dependencies": [
              4,
              5
            ],
            "details": "Modify the computed 'prescription' property in PrescriptionForm.vue to include duration and durationUnit fields. Use spread operator pattern similar to metaboliteLife: only include if duration has a valid value. Ensure both fields are included together when duration is set.",
            "status": "pending",
            "testStrategy": "Component test: submit form and verify emitted prescription object contains duration and durationUnit with correct values. Test with duration unset.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Modify accumulateDoses to use prescription duration",
            "description": "Update the accumulateDoses function to calculate numDays from prescription.duration instead of endHours parameter when duration is provided.",
            "dependencies": [
              1
            ],
            "details": "In multiDose.ts accumulateDoses(), check if prescription has duration field. If present, convert duration to hours (multiply by 24 if unit is 'days'), then calculate numDays from this value instead of using endHours/24. Keep existing logic as fallback when duration is not provided for backward compatibility.",
            "status": "pending",
            "testStrategy": "Unit test accumulateDoses with prescriptions having: no duration (uses endHours), duration in days, duration in hours. Verify correct number of dose times are generated.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Update getGraphData to handle duration-aware prescriptions",
            "description": "Modify getGraphData to derive graph timeframe from prescription duration when available.",
            "dependencies": [
              7
            ],
            "details": "In multiDose.ts getGraphData(), when prescription has duration, use it to calculate the effective endHours for that prescription's curve. This allows each prescription to have its own duration while still rendering on a common time axis. The overall graph timeframe should accommodate the longest duration prescription.",
            "status": "pending",
            "testStrategy": "Test getGraphData with mixed prescriptions: some with duration, some without. Verify all curves render correctly and graph timeframe covers longest duration.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Update App.vue to pass duration-aware parameters",
            "description": "Modify App.vue to work with duration-based calculations and adjust timeframe slider behavior accordingly.",
            "dependencies": [
              6,
              8
            ],
            "details": "In App.vue, update graphDatasets computed property to work with prescriptions that have duration fields. Consider whether timeframe slider should override or complement prescription duration. Update slider label to reflect duration-based behavior when applicable. May need to compute effective endHours from prescription duration.",
            "status": "pending",
            "testStrategy": "Integration testing: create prescription with duration, verify graph displays correct timeframe. Test slider still functions. Test interaction between slider and prescription duration.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Add CSS styling for duration input group",
            "description": "Style the duration input and unit toggle as a cohesive input group in PrescriptionForm scoped styles.",
            "dependencies": [
              5
            ],
            "details": "Add CSS rules in PrescriptionForm.vue <style scoped> for .duration-input-group with flexbox layout to position number input and unit select side-by-side. Ensure consistent styling with other form fields, proper spacing, focus states, and responsive behavior on mobile. Consider adding visual grouping border or background.",
            "status": "pending",
            "testStrategy": "Visual testing across viewport sizes. Verify consistent look with other form fields. Check focus states and mobile responsiveness.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: (1) Add duration input to PrescriptionForm with toggle for days/hours unit - extends form state with duration: number and durationUnit: 'days'|'hours', update Prescription interface, (2) Modify multiDose.ts accumulateDoses to use prescription duration instead of calculating from startHours/endHours - changes how numDays is computed in expandDoseTimes, (3) Update App.vue to pass duration-aware parameters to getGraphData, adjust timeframe slider to work with duration-based calculations. May need validation: duration must be positive, reasonable maximum.",
        "updatedAt": "2026-02-14T22:46:08.716Z"
      },
      {
        "id": "17",
        "title": "Comprehensive MVP Verification and Validation",
        "description": "Execute comprehensive verification that all MVP requirements are satisfied, including manual testing across browsers and devices, edge case validation, accessibility audits, and final sign-off documentation.",
        "details": "## Overview\n\nThis task validates that the Pharmacokinetics Grapher MVP is complete, functional, and ready for release. It encompasses manual verification of all features, cross-browser testing, responsive design validation, accessibility compliance, and documentation of sign-off status.\n\n## Phase 1: Automated Test Suite Verification\n\n### 1.1 Run Full Test Suite\n```bash\nnpm run test:unit\nnpm run type-check\nnpm run lint\nnpm run build\n```\n\n### 1.2 Verify Test Coverage\n- Confirm all test files pass:\n  - `src/core/models/__tests__/prescription.spec.ts` - Validation logic\n  - `src/core/calculations/__tests__/pkCalculator.spec.ts` - Single-dose calculations\n  - `src/core/calculations/__tests__/multiDose.spec.ts` - Multi-dose accumulation\n  - `src/core/storage/__tests__/prescriptionStorage.spec.ts` - localStorage CRUD\n  - `src/components/__tests__/PrescriptionForm.spec.ts` - Form component\n  - `src/components/__tests__/PrescriptionList.spec.ts` - List component\n  - `src/components/__tests__/GraphViewer.spec.ts` - Chart component\n  - `src/__tests__/App.spec.ts` - App integration\n\n## Phase 2: Manual Feature Verification Checklist\n\n### 2.1 PrescriptionForm Component (`src/components/PrescriptionForm.vue`)\n- [ ] Drug name input accepts 1-100 characters\n- [ ] Frequency dropdown shows all 8 options (once, bid, tid, qid, q6h, q8h, q12h, custom)\n- [ ] Selecting frequency auto-adjusts number of time inputs\n- [ ] Dose input enforces 0.001-10,000 range\n- [ ] Half-life input enforces 0.1-240 hours range\n- [ ] Peak (Tmax) input enforces 0.1-48 hours range\n- [ ] Uptake input enforces 0.1-24 hours range\n- [ ] Metabolite half-life is optional (0.1-1000 hours if provided)\n- [ ] Validation errors display in red alert box with role=\"alert\"\n- [ ] Validation warnings display in amber box for uptake >= halfLife\n- [ ] Submit button disabled when form invalid\n- [ ] Educational disclaimer banner visible\n- [ ] Import prescriptions link/modal functional\n\n### 2.2 GraphViewer Component (`src/components/GraphViewer.vue`)\n- [ ] Chart.js renders pharmacokinetic curves correctly\n- [ ] X-axis labeled \"Time (hours)\" with appropriate tick intervals\n- [ ] Y-axis labeled \"Relative Concentration (0–1)\" with 0.1 step\n- [ ] Legend displays drug names with color coding\n- [ ] Legend click toggles individual curve visibility\n- [ ] Tooltip shows time and concentration on hover\n- [ ] Download as PNG button functional\n- [ ] Educational disclaimer visible above chart\n- [ ] Chart responsive on window resize\n- [ ] Canvas has appropriate aria-label for accessibility\n\n### 2.3 PrescriptionList Component (`src/components/PrescriptionList.vue`)\n- [ ] Empty state message when no prescriptions saved\n- [ ] Lists all saved prescriptions with name, frequency badge, dose, half-life\n- [ ] View button navigates to graph view\n- [ ] Edit button loads prescription into form\n- [ ] Duplicate button creates copy\n- [ ] Delete button shows confirmation, removes item\n- [ ] Compare Mode toggle enables multi-select\n- [ ] Compare bar shows selected count\n- [ ] Compare Selected button emits compare event\n\n### 2.4 App.vue Integration\n- [ ] Tab navigation (Add New, Saved Prescriptions, Graph)\n- [ ] Tab keyboard navigation (arrow keys)\n- [ ] ARIA live region announces view changes\n- [ ] Graph tab only appears when prescriptions selected\n- [ ] Timeframe slider adjusts graph range (12-168 hours)\n- [ ] Save Prescription button persists current prescription\n- [ ] New Prescription button resets to form view\n- [ ] Auto-switch from graph to list when all compared prescriptions deleted\n\n### 2.5 Pharmacokinetic Calculations\n- [ ] Single dose curve shows absorption phase, peak, decay\n- [ ] Multi-dose (bid/tid/qid) shows accumulation pattern\n- [ ] Steady-state reached after ~5 half-lives\n- [ ] ka ≈ ke edge case uses fallback formula\n- [ ] Zero dose results in flat zero concentration\n- [ ] Normalized curves peak at 1.0\n\n## Phase 3: Cross-Browser Testing\n\n### 3.1 Desktop Browsers\n| Browser | Version | Form | Graph | List | Storage | Notes |\n|---------|---------|------|-------|------|---------|-------|\n| Chrome | Latest | ☐ | ☐ | ☐ | ☐ | |\n| Firefox | Latest | ☐ | ☐ | ☐ | ☐ | |\n| Safari | Latest | ☐ | ☐ | ☐ | ☐ | |\n| Edge | Latest | ☐ | ☐ | ☐ | ☐ | |\n\n### 3.2 Test Scenarios per Browser\n1. Create prescription with bid frequency\n2. Save prescription to localStorage\n3. Reload page, verify prescription persists\n4. View graph, verify curve renders\n5. Download PNG, verify file saves\n6. Edit prescription, verify changes persist\n7. Compare 2+ prescriptions on graph\n8. Delete prescription, verify removal\n\n## Phase 4: Mobile/Tablet Responsive Testing\n\n### 4.1 Viewport Breakpoints\n- [ ] Mobile portrait (375px width)\n- [ ] Mobile landscape (667px width)\n- [ ] Tablet portrait (768px width)\n- [ ] Tablet landscape (1024px width)\n\n### 4.2 Responsive Behavior Verification\n- [ ] Form fields stack vertically on mobile\n- [ ] Graph height reduces to 300px on mobile (< 768px)\n- [ ] Legend moves to bottom on mobile\n- [ ] Action buttons stack vertically on mobile\n- [ ] Tab navigation buttons remain accessible\n- [ ] Time input fields usable on touch\n- [ ] Number inputs show numeric keyboard on mobile\n\n### 4.3 Touch Interaction Testing\n- [ ] Tap to select frequency dropdown\n- [ ] Tap time inputs opens native time picker\n- [ ] Swipe/scroll through prescription list\n- [ ] Pinch-zoom on graph (if supported by Chart.js)\n- [ ] Tap legend items to toggle curves\n\n## Phase 5: Edge Case Validation\n\n### 5.1 Input Boundary Testing\n- [ ] Minimum dose (0.001) renders valid curve\n- [ ] Maximum dose (10000) renders without overflow\n- [ ] Minimum half-life (0.1 hours) shows rapid decay\n- [ ] Maximum half-life (240 hours) shows slow decay over days\n- [ ] Uptake = halfLife triggers warning and fallback formula\n- [ ] 100-character drug name displays without truncation\n\n### 5.2 Storage Edge Cases\n- [ ] localStorage quota exceeded handling (graceful failure)\n- [ ] Corrupted localStorage data handling (recovery/reset)\n- [ ] 50+ prescriptions performance test\n- [ ] Duplicate prescription IDs handled\n\n### 5.3 Graph Edge Cases\n- [ ] Single point (once frequency, minimal timeframe)\n- [ ] 8 simultaneous prescriptions (color palette cycles)\n- [ ] Timeframe slider at minimum (12h) and maximum (168h)\n- [ ] Very short half-life (0.1h) visible in 12h window\n- [ ] Very long half-life (240h) meaningful in 168h window\n\n### 5.4 Calculation Edge Cases\n- [ ] Zero time point (t=0) returns 0 concentration\n- [ ] Negative time (should not occur) handled gracefully\n- [ ] ka exactly equals ke (denominator zero protection)\n- [ ] Very large accumulation factor (> 100 doses)\n\n## Phase 6: Accessibility Audit\n\n### 6.1 Screen Reader Testing\n- [ ] Form labels read correctly\n- [ ] Validation errors announced via role=\"alert\"\n- [ ] View changes announced via aria-live region\n- [ ] Chart has descriptive aria-label\n- [ ] Legend interaction accessible via keyboard\n\n### 6.2 Keyboard Navigation\n- [ ] Tab order logical through form fields\n- [ ] Arrow keys navigate between tabs\n- [ ] Enter key submits form\n- [ ] Escape closes import modal\n- [ ] Focus visible on all interactive elements\n\n### 6.3 Color Contrast\n- [ ] All text meets WCAG 2.1 AA (4.5:1 for normal, 3:1 for large)\n- [ ] Error messages (red on light background)\n- [ ] Warning messages (amber on light background)\n- [ ] Button states (enabled/disabled/hover)\n\n## Phase 7: Final Documentation\n\n### 7.1 Sign-Off Checklist\nCreate `docs/MVP-SIGNOFF.md` with:\n- [ ] All automated tests passing\n- [ ] All manual verification items completed\n- [ ] Cross-browser testing matrix complete\n- [ ] Mobile/tablet testing complete\n- [ ] Edge case validation complete\n- [ ] Accessibility audit complete\n- [ ] Build successful without warnings/errors\n- [ ] Production bundle size acceptable (< 500KB gzipped)\n\n### 7.2 Known Issues Documentation\nDocument any deferred items:\n- Performance optimizations for large datasets\n- PWA/offline support (future enhancement)\n- Export to PDF (future enhancement)\n- Print stylesheet (future enhancement)\n\n### 7.3 Release Notes Draft\nPrepare brief release notes summarizing:\n- Core features implemented\n- Browser compatibility\n- Accessibility compliance level\n- Educational disclaimer clarity",
        "testStrategy": "## Verification Approach\n\n### 1. Automated Test Execution\n```bash\n# Run complete test suite\nnpm run test:unit -- --reporter=verbose\n\n# Verify type safety\nnpm run type-check\n\n# Verify code quality\nnpm run lint\n\n# Verify production build\nnpm run build\nnpm run preview\n```\n\n### 2. Manual Testing Protocol\n\n**Test Environment Setup:**\n- Clear localStorage before testing: `localStorage.clear()`\n- Use browser DevTools responsive mode for viewport testing\n- Enable accessibility inspection in browser\n\n**Test Data Fixtures:**\n```typescript\n// Standard test prescription\n{\n  name: \"Ibuprofen\",\n  frequency: \"tid\",\n  times: [\"08:00\", \"14:00\", \"20:00\"],\n  dose: 400,\n  halfLife: 2,\n  peak: 1,\n  uptake: 0.5\n}\n\n// Edge case: ka ≈ ke\n{\n  name: \"Edge Case Drug\",\n  frequency: \"bid\",\n  times: [\"08:00\", \"20:00\"],\n  dose: 100,\n  halfLife: 4,\n  peak: 2,\n  uptake: 4  // Warning expected\n}\n\n// Extreme values\n{\n  name: \"Extreme Long HalfLife\",\n  frequency: \"once\",\n  times: [\"09:00\"],\n  dose: 500,\n  halfLife: 240,\n  peak: 12,\n  uptake: 6\n}\n```\n\n### 3. Cross-Browser Testing Matrix\n\nExecute the following in each browser:\n1. Chrome (latest stable)\n2. Firefox (latest stable)\n3. Safari (latest on macOS)\n4. Edge (latest stable)\n\n**Per-Browser Test Sequence:**\n1. Load app, verify initial state\n2. Create prescription, submit form\n3. Verify graph renders with correct curve shape\n4. Save prescription, reload page\n5. Verify persistence\n6. Edit prescription, verify changes\n7. Compare 2 prescriptions\n8. Download PNG export\n9. Delete prescription\n\n### 4. Responsive Testing Protocol\n\nUse Chrome DevTools Device Mode:\n- iPhone SE (375×667)\n- iPhone 14 Pro (393×852)\n- iPad (768×1024)\n- Desktop (1280×720, 1920×1080)\n\n**Verify at each breakpoint:**\n- Layout adapts appropriately\n- Touch targets >= 44×44px\n- Text remains readable\n- Forms remain usable\n\n### 5. Accessibility Testing Tools\n\n- **Chrome Lighthouse**: Run accessibility audit\n- **axe DevTools**: Scan for WCAG violations\n- **Screen Reader**: Test with VoiceOver (macOS) or NVDA (Windows)\n\n### 6. Performance Verification\n\n```bash\n# Build and analyze bundle\nnpm run build\n\n# Check bundle size\nls -la dist/assets/*.js | awk '{print $5, $9}'\n```\n\n**Performance Criteria:**\n- Initial load < 3 seconds on 3G\n- Graph renders < 500ms\n- No memory leaks on repeated form submissions\n- localStorage operations < 100ms\n\n### 7. Sign-Off Documentation\n\nCreate verification evidence:\n```markdown\n# MVP Sign-Off Report\n\n## Test Results Summary\n- Automated Tests: XX/XX passing\n- Type Check: Clean\n- Lint: No errors\n- Build: Success\n\n## Browser Compatibility\n| Browser | Status | Notes |\n|---------|--------|-------|\n| Chrome  | ✅     |       |\n| Firefox | ✅     |       |\n| Safari  | ✅     |       |\n| Edge    | ✅     |       |\n\n## Accessibility\n- Lighthouse Score: XX/100\n- WCAG 2.1 AA: Compliant\n\n## Approved By: [Name]\n## Date: [Date]\n```",
        "status": "pending",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "9",
          "10"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "18",
        "title": "Fix math behind compounded dosage on graph",
        "description": "Investigation complete: No mathematical bug found in multi-dose accumulation. All 473 tests pass. Manual calculation verification confirms correct accumulation factor (1.332 actual vs 1.333 theoretical). Task blocked pending specific reproduction case from user.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "details": "## Investigation Complete - No Bug Found\n\n### Test Results (473/473 PASS)\n- 13 multiDose.spec.ts tests: PASS\n- 58 pkCalculator.spec.ts tests: PASS\n- All edge cases covered: BID accumulation, zero dose, normalization, time resolution\n\n### Mathematical Verification\nFor BID prescription (500mg, halfLife=6h, uptake=1.5h, times=[09:00, 21:00]):\n- First peak (t=13h): 314.98 concentration\n- Second peak (t=25h): 419.56 concentration\n- Accumulation factor: 1.332 (Theoretical: 1.333) MATCH\n\n### Code Review Summary\n\nFile: src/core/calculations/multiDose.ts\n- expandDoseTimes() (line 32): Correctly expands daily doses across simulation window\n- accumulateDoses() (line 56): Correctly sums raw contributions from all prior doses\n- Normalization (line 104-109): Divides by maxConc to produce peak=1.0\n\nFile: src/core/calculations/pkCalculator.ts\n- calculateConcentration() (line 56): Standard one-compartment formula\n- ka~ke fallback (line 73-75): Uses series expansion when |ka-ke| < tolerance\n- Guards for zero/negative values: Returns 0 appropriately\n\n### Formula Verified\nC(t) = Dose x [ka/(ka-ke)] x (e^(-ke*t) - e^(-ka*t))\nwhere ka = ln(2) / uptake, ke = ln(2) / halfLife\n\n## Blocked: Need Reproduction Case\n\nTo proceed, user must provide:\n1. Specific prescription parameters that produce incorrect output\n2. Expected vs actual behavior (what graph shows vs what it should show)\n3. Reference data source (pharmacology dataset to compare against)\n4. Clarification: Is this a display/visual issue or a mathematical issue?\n\nWithout a concrete failing scenario, cannot identify or fix any issue.",
        "testStrategy": "## Current Test Coverage (All Passing)\n\nmultiDose.spec.ts (13 tests): Single dose normalization, BID accumulation pattern, Zero dose handling, Time range accuracy, Time step resolution, Concentration normalization (0-1 range), Graph data generation\n\npkCalculator.spec.ts (58 tests): Single dose concentration, ka~ke edge case, Zero/negative input guards, Peak time calculation\n\n## Commands\nnpm run test -- src/core/calculations/__tests__/multiDose.spec.ts\nnpm run test -- src/core/calculations/__tests__/pkCalculator.spec.ts\nnpm run dev (for visual inspection)\n\n## If Bug is Identified\n1. Create failing test capturing expected behavior\n2. Implement fix\n3. Verify test passes and no regressions",
        "subtasks": [
          {
            "id": 1,
            "title": "Investigation complete - awaiting reproduction case",
            "description": "Thorough investigation found no mathematical errors. All 473 tests pass, manual calculation matches theoretical values (accumulation factor 1.332 vs 1.333). Code review of accumulateDoses() and calculateConcentration() shows correct implementation.",
            "dependencies": [],
            "details": "Investigation Results: Tests 473/473 PASS (multiDose.spec.ts 13 tests, pkCalculator.spec.ts 58 tests). Manual verification for BID 500mg halfLife=6h uptake=1.5h showed first peak 314.98, second peak 419.56, accumulation 1.332 matching theoretical 1.333. Code review confirmed expandDoseTimes(), accumulateDoses() summation, normalization, and calculateConcentration() are all correct. User must provide specific failing scenario to proceed.",
            "status": "done",
            "testStrategy": "N/A - investigation task complete. All existing tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "User provides specific reproduction case",
            "description": "Waiting for user to provide: (1) prescription parameters producing wrong output, (2) expected vs actual graph behavior, (3) reference pharmacology data for comparison, (4) clarification if issue is visual or mathematical",
            "dependencies": [
              1
            ],
            "details": "Required information: Prescription parameters (name, dose, halfLife, uptake, frequency, times), Expected behavior with reference source, Actual behavior with screenshot or description, Issue type classification (mathematical vs visual/display). Without this information cannot proceed - no bug has been identified to fix.",
            "status": "pending",
            "testStrategy": "Once reproduction case is provided, create failing test that captures the expected behavior and verify current implementation fails that test.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement fix based on identified issue",
            "description": "Once specific bug is identified and reproduced, implement fix with regression test",
            "dependencies": [
              1,
              2
            ],
            "details": "Conditional on bug identification. If mathematical issue: fix in multiDose.ts or pkCalculator.ts, add regression test, verify all existing tests pass. If display issue: fix in GraphViewer.vue, verify Chart.js data mapping. If no issue found: close as Cannot Reproduce with documented findings.",
            "status": "pending",
            "testStrategy": "Add specific regression test that fails before fix and passes after. Run full test suite to ensure no regressions with npm run test.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "19",
        "title": "Add Clock Time X-Axis Display Mode Toggle",
        "description": "Add an option to display clock-format times on the graph X-axis instead of hours. Users can toggle between \"Hours\" (0, 12, 24) and \"Clock Time\" (05:00, 12:00, 16:30) display modes, using the first dose time as the reference point.",
        "details": "## Overview\n\nImplement a display mode toggle for the graph X-axis that allows users to choose between viewing time as hours since first dose (current behavior) or as actual clock times based on the first dose time from the prescription.\n\n## Implementation Steps\n\n### 1. Update GraphViewer Props and State (`src/components/GraphViewer.vue`)\n\nAdd new props to support clock time display:\n\n```typescript\nconst props = withDefaults(\n  defineProps<{\n    datasets: GraphDataset[]\n    startHours?: number\n    endHours?: number\n    xAxisMode?: 'hours' | 'clock'        // NEW: Display mode toggle\n    firstDoseTime?: string               // NEW: Reference time in HH:MM format (e.g., \"09:00\")\n  }>(),\n  {\n    startHours: 0,\n    endHours: 48,\n    xAxisMode: 'hours',\n    firstDoseTime: '00:00',\n  },\n)\n```\n\n### 2. Create Time Formatting Utilities\n\nAdd helper functions in GraphViewer.vue (or extract to `src/core/utils/timeFormat.ts`):\n\n```typescript\n/**\n * Convert hours offset to clock time string\n * @param hoursOffset - Hours from reference (can be > 24)\n * @param referenceTime - Reference time in HH:MM format\n * @returns Clock time string in HH:MM format\n */\nfunction hoursToClockTime(hoursOffset: number, referenceTime: string): string {\n  const [refHours, refMinutes] = referenceTime.split(':').map(Number)\n  const totalMinutes = (refHours * 60 + refMinutes) + (hoursOffset * 60)\n  \n  // Wrap around 24-hour clock (handle multi-day simulation)\n  const minutes = Math.floor(totalMinutes % (24 * 60))\n  const hours = Math.floor(minutes / 60)\n  const mins = minutes % 60\n  \n  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`\n}\n\n/**\n * Determine appropriate tick step for clock time mode\n * Returns step in hours that aligns well with clock display\n */\nfunction calculateClockTickStep(startHours: number, endHours: number): number {\n  const range = endHours - startHours\n  if (range <= 12) return 1       // Every hour for short ranges\n  if (range <= 24) return 2       // Every 2 hours\n  if (range <= 72) return 4       // Every 4 hours\n  if (range <= 168) return 6      // Every 6 hours\n  return 12                        // Every 12 hours for week+ ranges\n}\n```\n\n### 3. Update Chart.js X-Axis Configuration\n\nModify the `renderChart()` function to handle both modes:\n\n```typescript\n// In renderChart() function, update scales.x configuration:\nscales: {\n  x: {\n    type: 'linear',\n    title: {\n      display: true,\n      text: props.xAxisMode === 'clock' ? 'Time of Day' : 'Time (hours)',\n      font: { size: 14 },\n    },\n    min: props.startHours,\n    max: props.endHours,\n    ticks: {\n      stepSize: props.xAxisMode === 'clock' \n        ? calculateClockTickStep(props.startHours, props.endHours)\n        : calculateTickStep(props.startHours, props.endHours),\n      callback: (value: string | number) => {\n        const num = typeof value === 'string' ? parseFloat(value) : value\n        if (props.xAxisMode === 'clock') {\n          return hoursToClockTime(num, props.firstDoseTime ?? '00:00')\n        }\n        return `${num}h`\n      },\n    },\n  },\n  // ... y-axis unchanged\n}\n```\n\n### 4. Update Tooltip for Clock Time Mode\n\nModify tooltip callback to show clock time when in clock mode:\n\n```typescript\ntooltip: {\n  // ... existing config\n  callbacks: {\n    title: (items) => {\n      if (items.length > 0 && items[0]?.parsed?.x !== undefined) {\n        const hours = items[0].parsed.x as number\n        if (props.xAxisMode === 'clock') {\n          const clockTime = hoursToClockTime(hours, props.firstDoseTime ?? '00:00')\n          // Show both clock time and day indicator for multi-day\n          const dayNum = Math.floor(hours / 24) + 1\n          return dayNum > 1 ? `${clockTime} (Day ${dayNum})` : clockTime\n        }\n        return `Time: ${hours.toFixed(1)}h`\n      }\n      return ''\n    },\n    // ... label callback unchanged\n  },\n},\n```\n\n### 5. Add Toggle Control in App.vue\n\nAdd UI control and state for X-axis mode in `src/App.vue`:\n\n```typescript\n// Add state\nconst xAxisMode = ref<'hours' | 'clock'>('hours')\n\n// Compute first dose time from compared prescriptions\nconst firstDoseTime = computed(() => {\n  if (comparePrescriptions.value.length === 0) return '00:00'\n  // Get earliest dose time from all prescriptions\n  const allTimes = comparePrescriptions.value.flatMap(rx => rx.times)\n  if (allTimes.length === 0) return '00:00'\n  return allTimes.sort()[0] // Earliest HH:MM time\n})\n```\n\nUpdate template to pass props and add toggle:\n\n```html\n<GraphViewer\n  :datasets=\"graphDatasets\"\n  :start-hours=\"startHours\"\n  :end-hours=\"endHours\"\n  :x-axis-mode=\"xAxisMode\"\n  :first-dose-time=\"firstDoseTime\"\n/>\n\n<!-- Add toggle in graph-controls section -->\n<div class=\"graph-controls\">\n  <div class=\"x-axis-toggle\">\n    <span class=\"toggle-label\">X-Axis Display:</span>\n    <button\n      :class=\"{ active: xAxisMode === 'hours' }\"\n      @click=\"xAxisMode = 'hours'\"\n      type=\"button\"\n    >\n      Hours (0, 12, 24...)\n    </button>\n    <button\n      :class=\"{ active: xAxisMode === 'clock' }\"\n      @click=\"xAxisMode = 'clock'\"\n      type=\"button\"\n    >\n      Clock Time\n    </button>\n  </div>\n  <!-- existing timeframe slider -->\n</div>\n```\n\n### 6. Update Accessibility\n\nUpdate `chartAriaLabel` computed property to mention time format:\n\n```typescript\nconst chartAriaLabel = computed(() => {\n  if (props.datasets.length === 0) {\n    return 'Pharmacokinetic graph - no data loaded'\n  }\n  const drugList = props.datasets.map((ds) => ds.label).join(', ')\n  const timeFormat = props.xAxisMode === 'clock' \n    ? `Clock time starting from ${props.firstDoseTime}` \n    : `Hours from ${props.startHours} to ${props.endHours}`\n  return `Pharmacokinetic concentration graph showing: ${drugList}. ${timeFormat}. Y-axis: relative concentration 0 to 1.`\n})\n```\n\n### 7. Add Watch for Mode Changes\n\nEnsure chart re-renders when mode changes:\n\n```typescript\nwatch(\n  [() => props.datasets, () => props.startHours, () => props.endHours, \n   () => props.xAxisMode, () => props.firstDoseTime, isMobile],  // Add xAxisMode and firstDoseTime\n  () => {\n    renderChart()\n  },\n  { deep: true },\n)\n```\n\n## Edge Cases to Handle\n\n1. **Multi-day simulations**: When hours exceed 24, show day indicator in tooltips (e.g., \"08:00 (Day 2)\")\n2. **No prescriptions loaded**: Default to 00:00 as reference time\n3. **Multiple prescriptions with different times**: Use earliest first dose time across all\n4. **Fractional hours**: Round to nearest minute for display (e.g., 2.5h = 02:30 from midnight)\n\n## Styling\n\nAdd CSS for toggle buttons in App.vue:\n\n```css\n.x-axis-toggle {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  margin-bottom: 1rem;\n}\n\n.toggle-label {\n  font-weight: 500;\n  color: #374151;\n}\n\n.x-axis-toggle button {\n  padding: 0.5rem 1rem;\n  border: 1px solid #d1d5db;\n  background: white;\n  border-radius: 4px;\n  cursor: pointer;\n  font-size: 0.875rem;\n  transition: all 0.2s;\n}\n\n.x-axis-toggle button.active {\n  background: #3b82f6;\n  color: white;\n  border-color: #3b82f6;\n}\n\n.x-axis-toggle button:hover:not(.active) {\n  background: #f3f4f6;\n}\n```",
        "testStrategy": "## Unit Tests for Time Formatting (`src/core/utils/__tests__/timeFormat.spec.ts`)\n\n```typescript\ndescribe('hoursToClockTime', () => {\n  it('converts 0 hours from 09:00 to 09:00', () => {\n    expect(hoursToClockTime(0, '09:00')).toBe('09:00')\n  })\n\n  it('converts 3 hours from 09:00 to 12:00', () => {\n    expect(hoursToClockTime(3, '09:00')).toBe('12:00')\n  })\n\n  it('converts 12 hours from 09:00 to 21:00', () => {\n    expect(hoursToClockTime(12, '09:00')).toBe('21:00')\n  })\n\n  it('wraps past midnight correctly (15h from 09:00 = 00:00)', () => {\n    expect(hoursToClockTime(15, '09:00')).toBe('00:00')\n  })\n\n  it('wraps to next day correctly (27h from 09:00 = 12:00)', () => {\n    expect(hoursToClockTime(27, '09:00')).toBe('12:00')\n  })\n\n  it('handles fractional hours (2.5h from 09:00 = 11:30)', () => {\n    expect(hoursToClockTime(2.5, '09:00')).toBe('11:30')\n  })\n\n  it('handles reference time with minutes (2h from 09:30 = 11:30)', () => {\n    expect(hoursToClockTime(2, '09:30')).toBe('11:30')\n  })\n\n  it('pads single-digit hours with leading zero', () => {\n    expect(hoursToClockTime(0, '05:00')).toBe('05:00')\n  })\n})\n\ndescribe('calculateClockTickStep', () => {\n  it('returns 1 for ranges <= 12 hours', () => {\n    expect(calculateClockTickStep(0, 12)).toBe(1)\n  })\n\n  it('returns 2 for ranges <= 24 hours', () => {\n    expect(calculateClockTickStep(0, 24)).toBe(2)\n  })\n\n  it('returns 4 for ranges <= 72 hours', () => {\n    expect(calculateClockTickStep(0, 72)).toBe(4)\n  })\n\n  it('returns 12 for week+ ranges', () => {\n    expect(calculateClockTickStep(0, 200)).toBe(12)\n  })\n})\n```\n\n## Component Tests for GraphViewer (`src/components/__tests__/GraphViewer.spec.ts`)\n\nAdd tests to existing file:\n\n```typescript\ndescribe('clock time x-axis mode', () => {\n  const datasets = [\n    { label: 'Test', data: [{ time: 0, concentration: 0 }, { time: 12, concentration: 0.5 }] },\n  ]\n\n  it('defaults to hours mode when xAxisMode not provided', () => {\n    mount(GraphViewer, { props: { datasets } })\n    const config = (MockChart as any).mock.calls[0]?.[1]\n    expect(config?.options?.scales?.x?.title?.text).toBe('Time (hours)')\n  })\n\n  it('uses \"Time of Day\" title when xAxisMode is clock', () => {\n    mount(GraphViewer, { props: { datasets, xAxisMode: 'clock', firstDoseTime: '09:00' } })\n    const config = (MockChart as any).mock.calls[0]?.[1]\n    expect(config?.options?.scales?.x?.title?.text).toBe('Time of Day')\n  })\n\n  it('tick callback formats as clock time when in clock mode', () => {\n    mount(GraphViewer, { props: { datasets, xAxisMode: 'clock', firstDoseTime: '09:00' } })\n    const config = (MockChart as any).mock.calls[0]?.[1]\n    const tickCallback = config?.options?.scales?.x?.ticks?.callback\n    expect(tickCallback(12)).toBe('21:00')  // 12 hours after 09:00\n  })\n\n  it('tick callback formats as hours when in hours mode', () => {\n    mount(GraphViewer, { props: { datasets, xAxisMode: 'hours' } })\n    const config = (MockChart as any).mock.calls[0]?.[1]\n    const tickCallback = config?.options?.scales?.x?.ticks?.callback\n    expect(tickCallback(12)).toBe('12h')\n  })\n\n  it('re-renders chart when xAxisMode changes', async () => {\n    const wrapper = mount(GraphViewer, { props: { datasets, xAxisMode: 'hours' } })\n    await wrapper.setProps({ xAxisMode: 'clock', firstDoseTime: '09:00' })\n    expect(MockChart).toHaveBeenCalledTimes(2)\n  })\n\n  it('updates aria-label to reflect clock time mode', () => {\n    const wrapper = mount(GraphViewer, { \n      props: { datasets, xAxisMode: 'clock', firstDoseTime: '09:00' } \n    })\n    const ariaLabel = wrapper.find('canvas').attributes('aria-label')\n    expect(ariaLabel).toContain('Clock time')\n    expect(ariaLabel).toContain('09:00')\n  })\n\n  it('tooltip shows day indicator for multi-day hours in clock mode', () => {\n    mount(GraphViewer, { props: { datasets, xAxisMode: 'clock', firstDoseTime: '09:00' } })\n    const config = (MockChart as any).mock.calls[0]?.[1]\n    const titleCallback = config?.options?.plugins?.tooltip?.callbacks?.title\n    \n    const mockItems = [{ parsed: { x: 27 } }]  // 27 hours = day 2\n    const result = titleCallback(mockItems)\n    expect(result).toContain('Day 2')\n  })\n})\n```\n\n## Integration Tests for App.vue Toggle\n\n```typescript\ndescribe('X-axis mode toggle', () => {\n  it('renders toggle buttons', () => {\n    const wrapper = mount(App)\n    // Navigate to graph view first\n    // ...\n    expect(wrapper.find('.x-axis-toggle').exists()).toBe(true)\n  })\n\n  it('toggles between hours and clock mode', async () => {\n    const wrapper = mount(App)\n    // Setup and navigate to graph\n    // ...\n    const clockBtn = wrapper.find('.x-axis-toggle button:nth-child(3)')\n    await clockBtn.trigger('click')\n    expect(clockBtn.classes()).toContain('active')\n  })\n\n  it('computes firstDoseTime from earliest prescription time', () => {\n    // Test computed property with multiple prescriptions\n  })\n})\n```\n\n## Manual Testing Checklist\n\n1. **Basic Toggle Functionality**\n   - [ ] Load a prescription and view graph\n   - [ ] Toggle to \"Clock Time\" mode - X-axis labels change to HH:MM format\n   - [ ] Toggle back to \"Hours\" mode - X-axis labels return to numeric hours\n   - [ ] Toggle state persists while viewing same prescription\n\n2. **Clock Time Accuracy**\n   - [ ] First dose at 09:00, verify X-axis starts showing 09:00\n   - [ ] 12 hours later shows 21:00\n   - [ ] 15 hours after 09:00 wraps to 00:00\n   - [ ] Multi-day simulation shows correct wrapped times\n\n3. **Tooltip Verification**\n   - [ ] Hover over graph in clock mode - tooltip shows clock time\n   - [ ] Hover at 27h mark with 09:00 reference - shows \"12:00 (Day 2)\"\n   - [ ] Hours mode tooltip still shows \"Time: X.Xh\"\n\n4. **Multiple Prescriptions**\n   - [ ] Compare 2 prescriptions with different first dose times\n   - [ ] Verify earliest time is used as reference\n\n5. **Accessibility**\n   - [ ] Screen reader announces updated time format in aria-label\n   - [ ] Toggle buttons are keyboard accessible\n   - [ ] Focus states visible on toggle buttons\n\n6. **Responsive Design**\n   - [ ] Toggle buttons render correctly on mobile\n   - [ ] Clock times remain readable at narrow widths",
        "status": "done",
        "dependencies": [
          "9"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-15T00:36:47.291Z"
      },
      {
        "id": "20",
        "title": "Fix: Dark mode label readability issue",
        "description": "In dark mode, field labels are white on a grey background and unreadable. Need to improve contrast or adjust background color so labels are visible.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-15T11:03:54.757Z"
      },
      {
        "id": "21",
        "title": "Fix: Form reverts medication duration on edit submission",
        "description": "When editing a saved medication, the medication duration field keeps prompting for a valid entry. If you enter a value, when submitting the form, it reverts to the existing value instead of saving the new value.",
        "details": "",
        "testStrategy": "",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-15T11:18:29.065Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-15T11:20:46.858Z",
      "taskCount": 21,
      "completedCount": 17,
      "tags": [
        "master"
      ]
    }
  }
}