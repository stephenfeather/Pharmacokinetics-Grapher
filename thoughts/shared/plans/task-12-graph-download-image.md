# Implementation Plan: Task 12 -- Make Graph Downloadable as Image

Generated: 2026-02-14

## Goal

Enable users to download the pharmacokinetic graph rendered by `GraphViewer.vue` as a PNG image file. This allows saving, sharing, and documenting concentration curves generated by the app. The implementation adds an export utility module under `src/core/export/`, exposes the Chart.js instance from `GraphViewer.vue` via `defineExpose`, adds a Download button to the graph UI, and wires the full export pipeline together.

## Existing Codebase Analysis (VERIFIED)

### Files read and verified:

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/src/components/GraphViewer.vue`** (202 lines): The chart component. Key findings:
  - Uses `<script setup lang="ts">` with Composition API (line 1)
  - `chartInstance` is a module-scoped `let` variable of type `Chart | null` (line 26)
  - `canvasRef` is `ref<HTMLCanvasElement | null>(null)` (line 24)
  - `renderChart()` creates a new `Chart` instance on the canvas (lines 52-145)
  - **No `defineExpose` is currently used** -- the chart instance is entirely internal
  - Template structure: `.graph-viewer` > `.disclaimer` + `.chart-container` > `canvas` (lines 169-178)
  - No download button exists yet
  - Uses `Chart` import from `chart.js` and `GraphDataset` type from `@/core/models/prescription`
  - Props: `datasets: GraphDataset[]`, `startHours?: number` (default 0), `endHours?: number` (default 48)

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/src/App.vue`** (257 lines): The main app component. Key findings:
  - Imports and renders `GraphViewer` inside `.graph-section` div (lines 66-69)
  - GraphViewer has no `ref` template attribute -- parent does not reference the instance
  - Action buttons use classes `.btn .btn-primary` and `.btn .btn-secondary` (lines 85-90)
  - `.actions` div contains "Save Prescription" and "New Prescription" buttons (lines 84-91)
  - Button styling: `padding: 0.75rem 1.5rem`, `font-size: 1rem`, `border-radius: 6px`, `font-weight: 600`, `flex: 1`, `min-width: 150px` (lines 197-216)
  - Mobile responsive: buttons become `width: 100%` under 768px (lines 253-254)

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/src/components/__tests__/GraphViewer.spec.ts`** (329 lines): Existing test file. Key patterns:
  - Uses `vi.hoisted()` for mock setup before module loading (lines 7-17)
  - Mocks `chart.js` module: `vi.mock('chart.js', () => ({ Chart: MockChart, registerables: [] }))` (lines 19-22)
  - `MockChart` is a `vi.fn()` constructor with `this.destroy = mockDestroy` (lines 11-13)
  - Tests verify Chart constructor calls, config objects, lifecycle (destroy/recreate), and edge cases
  - Uses `mount()` from `@vue/test-utils` with `props: { datasets }` pattern
  - Tests organized in describe blocks: "component structure", "chart creation", "lifecycle management", "edge cases"

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/src/core/models/prescription.ts`** (lines 1-119): Type definitions:
  - `GraphDataset { label: string; data: TimeSeriesPoint[]; color?: string }` (lines 32-36)
  - `Prescription` interface with `name: string`, `frequency: FrequencyLabel`, etc. (lines 13-23)

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/src/core/calculations/index.ts`**: Barrel export pattern -- re-exports named functions from implementation files.

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/src/core/storage/index.ts`**: Same barrel export pattern -- re-exports all named functions from `prescriptionStorage.ts`.

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/src/core/models/__tests__/fixtures.ts`**: Six test fixtures (e.g., `SINGLE_DOSE_FIXTURE`, `BID_MULTI_DOSE_FIXTURE`, `IBUPROFEN_FIXTURE`). These can be used to create meaningful filenames in tests.

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/package.json`**: `chart.js: "^4.5.1"`, `vitest: "^4.0.18"`, `vue: "^3.5.27"`. Test environment is jsdom (from `vitest.config.ts`).

- **`/Users/stephenfeather/Development/Pharmacokinetics-Grapher/node_modules/chart.js/dist/core/core.controller.d.ts`** (line 185): Confirms `toBase64Image(...args: any[]): any` exists on the Chart class. The method signature accepts optional `type` (MIME string) and `quality` (number 0-1) arguments, forwarded to the underlying `canvas.toDataURL()`.

### Directory structure:
- `src/core/` contains: `calculations/`, `models/`, `storage/` -- each with an `index.ts` barrel and a `__tests__/` subdirectory
- `src/core/export/` does **not** exist -- must be created
- No `defineExpose` is used anywhere in the current codebase (grep returned 0 matches)

### Chart.js toBase64Image API (VERIFIED from type definitions):

```typescript
// From chart.js/dist/core/core.controller.d.ts line 185
toBase64Image(...args: any[]): any;
```

The underlying implementation calls `canvas.toDataURL(type, quality)` where:
- `type` defaults to `'image/png'` (browser standard)
- `quality` is a number 0-1 for lossy formats like `'image/jpeg'`
- Returns a `data:image/png;base64,...` string (synchronous)

## Technical Approach

### Image Export Pipeline

The export flow is:

1. User clicks "Download Graph" button in GraphViewer
2. GraphViewer calls `chartInstance.toBase64Image()` to get a data URL
3. The data URL is passed to `downloadImage()` from the export utility
4. `downloadImage()` creates a temporary `<a>` element with `href=dataURL` and `download=filename.png`
5. The anchor is programmatically clicked, triggering the browser's file download
6. The anchor is removed from the DOM

This pattern is the standard browser-side file download approach. It is synchronous, requires no server, and works in all modern browsers.

### Why toBase64Image over canvas.toDataURL Directly

Chart.js's `toBase64Image()` is a convenience wrapper that:
- Handles the canvas reference internally (no need to access `canvasRef.value` from the export layer)
- Is the documented Chart.js export API
- Maintains consistency if Chart.js changes its rendering internals

The export utility will accept a data URL string (from any source), keeping it decoupled from Chart.js.

### Filename Strategy

Generated filenames will follow the pattern:
```
pk-graph-{drug-names}-{timestamp}.png
```

Examples:
- `pk-graph-ibuprofen-20260214-143022.png`
- `pk-graph-ibuprofen-acetaminophen-20260214-143022.png`
- `pk-graph-20260214-143022.png` (fallback when no datasets)

Drug names are sanitized (lowercase, non-alphanumeric characters replaced with hyphens, truncated for length).

## Implementation Phases

### Phase 1: Create Image Export Utility Module (Pure Functions)

**Priority**: 1 (Core -- no dependencies on Vue components)

**Files to create:**
- `src/core/export/imageExport.ts` -- Pure utility functions
- `src/core/export/index.ts` -- Barrel exports
- `src/core/export/__tests__/imageExport.spec.ts` -- Unit tests

**Implementation steps:**

#### Step 1.1: Create `src/core/export/imageExport.ts`

```typescript
// ---- Image Export Utilities ----

/**
 * Sanitize a string for use in a filename.
 * Converts to lowercase, replaces non-alphanumeric chars with hyphens,
 * collapses consecutive hyphens, and trims leading/trailing hyphens.
 */
export function sanitizeForFilename(input: string): string {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/-{2,}/g, '-')
    .replace(/^-|-$/g, '')
}

/**
 * Generate a timestamped filename for graph export.
 *
 * @param drugNames - Array of drug names from the graph datasets
 * @param format - Image format extension (default: 'png')
 * @param now - Optional Date for testing (default: new Date())
 * @returns Filename string like "pk-graph-ibuprofen-20260214-143022.png"
 */
export function generateFilename(
  drugNames: string[] = [],
  format: string = 'png',
  now: Date = new Date(),
): string {
  const timestamp = formatTimestamp(now)
  const namesPart = drugNames
    .map(sanitizeForFilename)
    .filter((n) => n.length > 0)
    .join('-')

  // Truncate combined names to keep filename reasonable (max 80 chars for names portion)
  const truncatedNames = namesPart.length > 80 ? namesPart.slice(0, 80) : namesPart

  const middle = truncatedNames.length > 0 ? `-${truncatedNames}` : ''
  return `pk-graph${middle}-${timestamp}.${format}`
}

/**
 * Format a Date as YYYYMMDD-HHmmss for filenames.
 */
function formatTimestamp(date: Date): string {
  const pad = (n: number) => String(n).padStart(2, '0')
  const y = date.getFullYear()
  const mo = pad(date.getMonth() + 1)
  const d = pad(date.getDate())
  const h = pad(date.getHours())
  const mi = pad(date.getMinutes())
  const s = pad(date.getSeconds())
  return `${y}${mo}${d}-${h}${mi}${s}`
}

/**
 * Trigger a browser file download from a data URL.
 *
 * Creates a temporary <a> element with the download attribute,
 * clicks it programmatically, and removes it.
 *
 * @param dataUrl - The data URL string (e.g., from canvas.toDataURL or Chart.toBase64Image)
 * @param filename - The filename for the downloaded file
 * @returns true if download was triggered, false if dataUrl was invalid
 */
export function downloadImage(dataUrl: string, filename: string): boolean {
  if (!dataUrl || !dataUrl.startsWith('data:')) {
    return false
  }

  const link = document.createElement('a')
  link.href = dataUrl
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  return true
}
```

#### Step 1.2: Create `src/core/export/index.ts`

```typescript
// Image export utilities
export { generateFilename, sanitizeForFilename, downloadImage } from './imageExport'
```

#### Step 1.3: Create `src/core/export/__tests__/imageExport.spec.ts`

Test coverage for all three exported functions:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { sanitizeForFilename, generateFilename, downloadImage } from '../imageExport'

describe('imageExport', () => {
  // ---- sanitizeForFilename ----

  describe('sanitizeForFilename', () => {
    it('converts to lowercase', () => {
      expect(sanitizeForFilename('Ibuprofen')).toBe('ibuprofen')
    })

    it('replaces spaces with hyphens', () => {
      expect(sanitizeForFilename('Test Drug')).toBe('test-drug')
    })

    it('replaces non-alphanumeric characters with hyphens', () => {
      expect(sanitizeForFilename('Drug (500mg)')).toBe('drug-500mg')
    })

    it('collapses consecutive hyphens', () => {
      expect(sanitizeForFilename('Drug---Name')).toBe('drug-name')
    })

    it('trims leading and trailing hyphens', () => {
      expect(sanitizeForFilename('--Drug--')).toBe('drug')
    })

    it('handles empty string', () => {
      expect(sanitizeForFilename('')).toBe('')
    })

    it('handles string with only special characters', () => {
      expect(sanitizeForFilename('---')).toBe('')
    })

    it('preserves numbers', () => {
      expect(sanitizeForFilename('Drug123')).toBe('drug123')
    })
  })

  // ---- generateFilename ----

  describe('generateFilename', () => {
    const fixedDate = new Date(2026, 1, 14, 14, 30, 22) // 2026-02-14 14:30:22

    it('generates filename with single drug name', () => {
      const result = generateFilename(['Ibuprofen'], 'png', fixedDate)
      expect(result).toBe('pk-graph-ibuprofen-20260214-143022.png')
    })

    it('generates filename with multiple drug names', () => {
      const result = generateFilename(['Ibuprofen', 'Acetaminophen'], 'png', fixedDate)
      expect(result).toBe('pk-graph-ibuprofen-acetaminophen-20260214-143022.png')
    })

    it('generates filename without drug names', () => {
      const result = generateFilename([], 'png', fixedDate)
      expect(result).toBe('pk-graph-20260214-143022.png')
    })

    it('generates filename with default empty array', () => {
      const result = generateFilename(undefined, 'png', fixedDate)
      expect(result).toBe('pk-graph-20260214-143022.png')
    })

    it('uses png format by default', () => {
      const result = generateFilename(['Drug'], undefined, fixedDate)
      expect(result).toBe('pk-graph-drug-20260214-143022.png')
    })

    it('supports jpeg format', () => {
      const result = generateFilename(['Drug'], 'jpeg', fixedDate)
      expect(result).toBe('pk-graph-drug-20260214-143022.jpeg')
    })

    it('sanitizes drug names in filename', () => {
      const result = generateFilename(['Drug (500mg)'], 'png', fixedDate)
      expect(result).toBe('pk-graph-drug-500mg-20260214-143022.png')
    })

    it('truncates very long combined names to 80 chars', () => {
      const longNames = Array.from({ length: 20 }, (_, i) => `VeryLongDrugName${i}`)
      const result = generateFilename(longNames, 'png', fixedDate)
      // Names part should be truncated
      expect(result.length).toBeLessThan(120) // pk-graph- + 80 chars max + -timestamp.png
    })

    it('filters out empty names after sanitization', () => {
      const result = generateFilename(['---', 'Ibuprofen'], 'png', fixedDate)
      expect(result).toBe('pk-graph-ibuprofen-20260214-143022.png')
    })
  })

  // ---- downloadImage ----

  describe('downloadImage', () => {
    let clickSpy: ReturnType<typeof vi.fn>
    let appendChildSpy: ReturnType<typeof vi.spyOn>
    let removeChildSpy: ReturnType<typeof vi.spyOn>

    beforeEach(() => {
      clickSpy = vi.fn()
      appendChildSpy = vi.spyOn(document.body, 'appendChild').mockImplementation((node) => node)
      removeChildSpy = vi.spyOn(document.body, 'removeChild').mockImplementation((node) => node)

      // Mock createElement to capture click
      vi.spyOn(document, 'createElement').mockImplementation((tag: string) => {
        const el = {
          tagName: tag.toUpperCase(),
          href: '',
          download: '',
          click: clickSpy,
          style: {},
        }
        return el as unknown as HTMLElement
      })
    })

    afterEach(() => {
      vi.restoreAllMocks()
    })

    it('returns true and triggers download for valid data URL', () => {
      const result = downloadImage('data:image/png;base64,abc123', 'test.png')
      expect(result).toBe(true)
      expect(clickSpy).toHaveBeenCalledOnce()
    })

    it('creates an anchor element with correct href and download attributes', () => {
      const dataUrl = 'data:image/png;base64,abc123'
      downloadImage(dataUrl, 'my-graph.png')

      const createCall = (document.createElement as ReturnType<typeof vi.fn>).mock.results[0]?.value
      expect(createCall.href).toBe(dataUrl)
      expect(createCall.download).toBe('my-graph.png')
    })

    it('appends and removes the anchor from document.body', () => {
      downloadImage('data:image/png;base64,abc123', 'test.png')
      expect(appendChildSpy).toHaveBeenCalledOnce()
      expect(removeChildSpy).toHaveBeenCalledOnce()
    })

    it('returns false for empty string', () => {
      const result = downloadImage('', 'test.png')
      expect(result).toBe(false)
      expect(clickSpy).not.toHaveBeenCalled()
    })

    it('returns false for non-data URL string', () => {
      const result = downloadImage('https://example.com/image.png', 'test.png')
      expect(result).toBe(false)
      expect(clickSpy).not.toHaveBeenCalled()
    })

    it('returns false for undefined-like input', () => {
      const result = downloadImage(null as unknown as string, 'test.png')
      expect(result).toBe(false)
    })
  })
})
```

**Acceptance criteria:**
- [ ] `sanitizeForFilename` correctly normalizes strings for filenames
- [ ] `generateFilename` produces correctly formatted timestamped filenames
- [ ] `downloadImage` creates anchor, sets attributes, triggers click, cleans up
- [ ] `downloadImage` returns false for invalid data URLs without side effects
- [ ] All tests pass with `npm run test:unit -- src/core/export/__tests__/imageExport.spec.ts`
- [ ] TypeScript compiles without errors

---

### Phase 2: Expose Chart Instance from GraphViewer via defineExpose

**Priority**: 1 (Required before download button can work)

**Files to modify:**
- `src/components/GraphViewer.vue` -- Add `defineExpose` and export methods

**Implementation steps:**

#### Step 2.1: Add `defineExpose` to GraphViewer.vue `<script setup>`

At the end of the `<script setup>` block (before `</script>`), add:

```typescript
// ---- Import export utility ----
import { generateFilename, downloadImage } from '@/core/export'

// ---- Exposed API ----

/**
 * Get the current Chart.js instance (or null if no chart is rendered).
 */
function getChartInstance(): Chart | null {
  return chartInstance
}

/**
 * Export the current chart as a PNG image and trigger browser download.
 * Returns true if download was triggered, false if no chart exists.
 */
function exportAsImage(): boolean {
  if (!chartInstance) {
    return false
  }

  const dataUrl = chartInstance.toBase64Image('image/png', 1.0) as string
  const drugNames = props.datasets.map((ds) => ds.label)
  const filename = generateFilename(drugNames)
  return downloadImage(dataUrl, filename)
}

defineExpose({
  getChartInstance,
  exportAsImage,
})
```

**Key decisions:**
- `exportAsImage()` is self-contained: it calls `toBase64Image`, generates the filename, and triggers the download. The parent component (App.vue) does not need to know about Chart.js internals.
- `getChartInstance()` is exposed for flexibility but the primary API is `exportAsImage()`.
- The method returns `boolean` so callers can detect success/failure.

**Acceptance criteria:**
- [ ] `defineExpose` exposes `getChartInstance` and `exportAsImage`
- [ ] `exportAsImage` returns `false` when no chart instance exists
- [ ] `exportAsImage` returns `true` when chart exists and download triggers
- [ ] No breaking changes to existing GraphViewer behavior or props
- [ ] TypeScript compiles without errors

---

### Phase 3: Add Download Button UI to GraphViewer

**Priority**: 1 (Core user-facing feature)

**Files to modify:**
- `src/components/GraphViewer.vue` -- Add button to template and styling

**Implementation steps:**

#### Step 3.1: Add reactive state for button feedback

In the `<script setup>` block, add:

```typescript
const isExporting = ref(false)
const hasDatasets = computed(() => props.datasets.length > 0)
```

#### Step 3.2: Add download handler function

```typescript
function handleDownload(): void {
  if (isExporting.value || !chartInstance) return
  isExporting.value = true

  // toBase64Image is synchronous, but we use a brief delay
  // to allow the UI to update with "Downloading..." state
  const success = exportAsImage()

  if (!success) {
    isExporting.value = false
    return
  }

  // Reset button state after a brief visual feedback period
  setTimeout(() => {
    isExporting.value = false
  }, 1000)
}
```

#### Step 3.3: Update template

Replace the existing template with:

```html
<template>
  <div class="graph-viewer">
    <div class="disclaimer">
      Educational purposes only. Not for medical decisions.
    </div>
    <div class="chart-container">
      <canvas ref="canvasRef"></canvas>
    </div>
    <div v-if="hasDatasets" class="graph-actions">
      <button
        type="button"
        class="download-btn"
        :disabled="isExporting"
        :aria-busy="isExporting"
        aria-label="Download graph as PNG image"
        data-testid="download-graph-btn"
        @click="handleDownload"
      >
        {{ isExporting ? 'Downloading...' : 'Download as PNG' }}
      </button>
    </div>
  </div>
</template>
```

#### Step 3.4: Add CSS styles

Add to the `<style scoped>` section:

```css
.graph-actions {
  display: flex;
  justify-content: flex-end;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #e5e7eb;
}

.download-btn {
  padding: 0.5rem 1rem;
  font-size: 0.9rem;
  font-weight: 600;
  border: 1px solid #3b82f6;
  border-radius: 6px;
  background: white;
  color: #3b82f6;
  cursor: pointer;
  transition: all 0.2s ease;
}

.download-btn:hover:not(:disabled) {
  background: #3b82f6;
  color: white;
}

.download-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
```

**Design rationale:**
- The download button uses an outlined style (white background, blue border) to visually distinguish it from the primary action buttons ("Save Prescription", "New Prescription") in App.vue which use filled backgrounds. This follows a secondary/tertiary button hierarchy.
- Positioned below the chart with `justify-content: flex-end` to avoid visual confusion with the chart itself.
- Only rendered when `hasDatasets` is true (no button when there is nothing to download).
- `data-testid="download-graph-btn"` follows the existing pattern from PrescriptionList tests.

**Accessibility:**
- `aria-label="Download graph as PNG image"` -- descriptive label for screen readers
- `aria-busy="true"` during export -- communicates processing state
- `:disabled` prevents double-clicks
- Button text changes to "Downloading..." for visual feedback
- Standard `<button>` element with `type="button"` -- fully keyboard accessible by default

**Acceptance criteria:**
- [ ] Download button appears only when datasets exist
- [ ] Button is disabled and shows "Downloading..." during export
- [ ] Button resets after 1 second feedback period
- [ ] Styling is consistent with project design (border-radius, colors, transitions)
- [ ] ARIA attributes present: `aria-label`, `aria-busy`
- [ ] `data-testid` present for testing

---

### Phase 4: Update GraphViewer Tests

**Priority**: 1 (Tests must cover all new functionality)

**Files to modify:**
- `src/components/__tests__/GraphViewer.spec.ts` -- Add test sections for new features

**Implementation steps:**

#### Step 4.1: Update MockChart to include `toBase64Image`

Update the `vi.hoisted()` block:

```typescript
const { mockDestroy, mockToBase64Image, MockChart } = vi.hoisted(() => {
  const mockDestroy = vi.fn()
  const mockToBase64Image = vi.fn().mockReturnValue('data:image/png;base64,mock-image-data')

  const MockChart = vi.fn(function (this: any) {
    this.destroy = mockDestroy
    this.toBase64Image = mockToBase64Image
  })
  ;(MockChart as any).register = vi.fn()

  return { mockDestroy, mockToBase64Image, MockChart: MockChart as any }
})
```

#### Step 4.2: Mock the export utility module

Add after the chart.js mock:

```typescript
const { mockDownloadImage } = vi.hoisted(() => {
  const mockDownloadImage = vi.fn().mockReturnValue(true)
  return { mockDownloadImage }
})

vi.mock('@/core/export', () => ({
  generateFilename: vi.fn(
    (names: string[] = []) => `pk-graph-${names.join('-')}-test.png`,
  ),
  downloadImage: mockDownloadImage,
}))
```

#### Step 4.3: Add new test sections

```typescript
// ---- Phase: Download Button ----

describe('download button', () => {
  it('does not render download button when datasets are empty', () => {
    const wrapper = mount(GraphViewer, { props: { datasets: [] } })
    expect(wrapper.find('[data-testid="download-graph-btn"]').exists()).toBe(false)
  })

  it('renders download button when datasets exist', () => {
    const datasets = [
      { label: 'Test', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    expect(wrapper.find('[data-testid="download-graph-btn"]').exists()).toBe(true)
  })

  it('download button text is "Download as PNG"', () => {
    const datasets = [
      { label: 'Test', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    expect(wrapper.find('[data-testid="download-graph-btn"]').text()).toBe('Download as PNG')
  })

  it('download button has aria-label', () => {
    const datasets = [
      { label: 'Test', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    const btn = wrapper.find('[data-testid="download-graph-btn"]')
    expect(btn.attributes('aria-label')).toBe('Download graph as PNG image')
  })

  it('download button has type="button"', () => {
    const datasets = [
      { label: 'Test', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    const btn = wrapper.find('[data-testid="download-graph-btn"]')
    expect(btn.attributes('type')).toBe('button')
  })
})

// ---- Phase: Export Functionality ----

describe('export functionality', () => {
  it('calls toBase64Image when download button is clicked', async () => {
    const datasets = [
      { label: 'Drug A', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    await wrapper.find('[data-testid="download-graph-btn"]').trigger('click')
    expect(mockToBase64Image).toHaveBeenCalledWith('image/png', 1.0)
  })

  it('calls downloadImage with generated filename', async () => {
    const datasets = [
      { label: 'Drug A', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    await wrapper.find('[data-testid="download-graph-btn"]').trigger('click')
    expect(mockDownloadImage).toHaveBeenCalledWith(
      'data:image/png;base64,mock-image-data',
      expect.stringContaining('pk-graph'),
    )
  })

  it('passes dataset labels to generateFilename', async () => {
    const { generateFilename } = await import('@/core/export')
    const datasets = [
      { label: 'Ibuprofen', data: [{ time: 0, concentration: 0 }] },
      { label: 'Aspirin', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    await wrapper.find('[data-testid="download-graph-btn"]').trigger('click')
    expect(generateFilename).toHaveBeenCalledWith(['Ibuprofen', 'Aspirin'])
  })

  it('hides download button after datasets become empty', async () => {
    const datasets = [
      { label: 'Test', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    expect(wrapper.find('[data-testid="download-graph-btn"]').exists()).toBe(true)

    await wrapper.setProps({ datasets: [] })
    expect(wrapper.find('[data-testid="download-graph-btn"]').exists()).toBe(false)
  })
})

// ---- Phase: defineExpose ----

describe('exposed methods', () => {
  it('exposes getChartInstance method', () => {
    const datasets = [
      { label: 'Test', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    const vm = wrapper.vm as any
    expect(typeof vm.getChartInstance).toBe('function')
  })

  it('getChartInstance returns null when no datasets', () => {
    const wrapper = mount(GraphViewer, { props: { datasets: [] } })
    const vm = wrapper.vm as any
    expect(vm.getChartInstance()).toBeNull()
  })

  it('exposes exportAsImage method', () => {
    const datasets = [
      { label: 'Test', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    const vm = wrapper.vm as any
    expect(typeof vm.exportAsImage).toBe('function')
  })

  it('exportAsImage returns false when no chart instance', () => {
    const wrapper = mount(GraphViewer, { props: { datasets: [] } })
    const vm = wrapper.vm as any
    expect(vm.exportAsImage()).toBe(false)
  })

  it('exportAsImage returns true when chart exists', () => {
    const datasets = [
      { label: 'Test', data: [{ time: 0, concentration: 0 }] },
    ]
    const wrapper = mount(GraphViewer, { props: { datasets } })
    const vm = wrapper.vm as any
    expect(vm.exportAsImage()).toBe(true)
  })
})
```

**Acceptance criteria:**
- [ ] MockChart updated with `toBase64Image` mock
- [ ] Export utility module is mocked
- [ ] Download button visibility tests pass (with/without datasets)
- [ ] Click handler tests verify `toBase64Image` and `downloadImage` are called correctly
- [ ] Exposed methods tests verify `getChartInstance` and `exportAsImage`
- [ ] All existing GraphViewer tests continue to pass
- [ ] All new tests pass with `npm run test:unit -- src/components/__tests__/GraphViewer.spec.ts`

---

### Phase 5: Integration -- Wire Download to App.vue (Optional Enhancement)

**Priority**: 3 (Enhancement -- the download button in GraphViewer is the primary UI)

**Files to modify:**
- `src/App.vue` -- Add ref to GraphViewer and optional external download button

**Implementation steps:**

This phase adds an alternative download trigger in the App.vue actions bar alongside "Save Prescription" and "New Prescription". This is optional because the download button inside GraphViewer (Phase 3) is the primary interaction.

#### Step 5.1: Add template ref to GraphViewer

```html
<GraphViewer
  ref="graphViewerRef"
  :datasets="graphDatasets"
  :start-hours="startHours"
  :end-hours="endHours"
/>
```

#### Step 5.2: Add ref and handler in script

```typescript
import type { ComponentPublicInstance } from 'vue'

interface GraphViewerExposed {
  getChartInstance: () => unknown
  exportAsImage: () => boolean
}

const graphViewerRef = ref<ComponentPublicInstance & GraphViewerExposed | null>(null)

function downloadGraph() {
  graphViewerRef.value?.exportAsImage()
}
```

#### Step 5.3: Add button to actions div (optional)

```html
<div class="actions">
  <button class="btn btn-primary" @click="saveCurrentPrescription">
    Save Prescription
  </button>
  <button class="btn btn-secondary" @click="downloadGraph">
    Download Graph
  </button>
  <button class="btn btn-secondary" @click="newPrescription">
    New Prescription
  </button>
</div>
```

**Note:** This phase is marked optional (Priority 3). The GraphViewer's built-in download button from Phase 3 is sufficient for the core feature. This phase adds redundant access from the action bar, which may or may not be desirable from a UX perspective. **Recommend deferring** unless specifically requested.

**Acceptance criteria:**
- [ ] Template ref correctly references GraphViewer component
- [ ] `downloadGraph()` calls `exportAsImage()` through the exposed API
- [ ] Button styling matches existing action buttons
- [ ] No errors when GraphViewer ref is null (guard clause)

---

## File Summary

### Files to CREATE:

| File | Purpose | Phase |
|------|---------|-------|
| `src/core/export/imageExport.ts` | Pure utility functions: `sanitizeForFilename`, `generateFilename`, `downloadImage` | 1 |
| `src/core/export/index.ts` | Barrel exports for export module | 1 |
| `src/core/export/__tests__/imageExport.spec.ts` | Unit tests for all export utility functions | 1 |

### Files to MODIFY:

| File | Changes | Phase |
|------|---------|-------|
| `src/components/GraphViewer.vue` | Add `defineExpose`, import export utils, download button, handler, styles | 2, 3 |
| `src/components/__tests__/GraphViewer.spec.ts` | Add `toBase64Image` to mock, add test sections for button/export/expose | 4 |
| `src/App.vue` | (Optional) Add `ref` to GraphViewer, add download button in actions | 5 |

## Implementation Order (Dependency Chain)

```
Phase 1: imageExport.ts + index.ts + tests
    |
    v
Phase 2: GraphViewer defineExpose (depends on Phase 1 for import)
    |
    v
Phase 3: GraphViewer download button UI (depends on Phase 2 for handler)
    |
    v
Phase 4: GraphViewer test updates (depends on Phases 2-3 for new behavior)
    |
    v
Phase 5: App.vue integration (depends on Phase 2 for exposed API) [OPTIONAL]
```

Phases 1 through 4 can be developed and tested incrementally. Each phase produces testable output before moving to the next.

## Testing Strategy

### Unit Tests (Phase 1)
- **`src/core/export/__tests__/imageExport.spec.ts`**: Tests all three utility functions in isolation
  - `sanitizeForFilename`: 8 cases (lowercase, spaces, special chars, empty, numbers, etc.)
  - `generateFilename`: 9 cases (single drug, multi drug, no drugs, formats, truncation, sanitization, defaults)
  - `downloadImage`: 6 cases (valid download, attributes, DOM manipulation, invalid inputs, null)
  - All use jsdom (already configured in vitest.config.ts)

### Component Tests (Phase 4)
- **`src/components/__tests__/GraphViewer.spec.ts`**: Extended test file
  - Download button: 5 tests (visibility, text, aria attributes, type)
  - Export functionality: 4 tests (toBase64Image called, downloadImage called, labels passed, button hides)
  - Exposed methods: 5 tests (getChartInstance exists/returns, exportAsImage exists/returns)
  - Mocking: chart.js mock extended with `toBase64Image`, export module mocked separately

### Integration Testing (Manual)
- Load the app, create a prescription, generate graph
- Click "Download as PNG" and verify a .png file downloads
- Verify filename contains drug name and timestamp
- Verify downloaded image shows the correct graph
- Test with multiple datasets overlaid
- Test button state: disabled during export, re-enabled after

### What Does NOT Need Testing
- Chart.js `toBase64Image` internals (third-party library)
- Browser file download mechanics beyond the anchor click pattern
- CSS styling (visual, not behavioral)

## Critical Decision Points

### Decision 1: Download Button Location

**Options:**
1. Inside `GraphViewer.vue` (self-contained)
2. In `App.vue` action bar (parent-controlled)
3. Both locations

**Recommendation:** Option 1 (inside GraphViewer) as primary. The component owns its chart and export logic. Option 3 can be added later (Phase 5) if desired.

**Rationale:** Keeping the download button inside GraphViewer maintains component encapsulation. The component knows when it has a chart and can manage its own export flow. Adding an external trigger via `defineExpose` is available but optional.

### Decision 2: Export Format

**Options:**
1. PNG only (default, lossless, transparent background)
2. PNG + JPEG (JPEG needs white background handling)

**Recommendation:** PNG only for initial implementation. JPEG support can be added later by extending `exportAsImage` with format parameters. Chart.js `toBase64Image` already supports both.

**Rationale:** PNG is the standard for charts/graphs. JPEG requires additional logic to fill the transparent background with white (Canvas `globalCompositeOperation` trick). Not worth the complexity for MVP.

### Decision 3: Filename Generation

**Options:**
1. Simple timestamp only (`pk-graph-20260214.png`)
2. Drug names + timestamp (`pk-graph-ibuprofen-20260214-143022.png`)
3. User-prompted filename

**Recommendation:** Option 2. Informative but automatic. No user prompt interrupts the flow.

### Decision 4: Button Feedback Mechanism

**Options:**
1. No feedback (instant)
2. Text change ("Downloading...") with brief timeout
3. Toast notification

**Recommendation:** Option 2. Lightweight, no additional dependencies. The 1-second "Downloading..." state provides visual confirmation without complexity.

## Risks and Mitigations

### Risk 1: jsdom `canvas.toDataURL()` Not Available

**Impact:** Medium -- affects tests, not production
**Likelihood:** Low -- the existing tests already mock Chart.js entirely

**Mitigation:** Tests mock `toBase64Image` at the Chart.js mock level (Phase 4, Step 4.1). The export utility's `downloadImage` is tested by mocking DOM methods. No actual canvas rendering is needed in tests.

### Risk 2: Large Image Data URLs

**Impact:** Low -- PNG of a 400px-height chart is typically 50-200KB
**Likelihood:** Very low

**Mitigation:** Chart.js `toBase64Image` handles encoding. The anchor-click download pattern works for any data URL size supported by the browser (several MB). No mitigation needed.

### Risk 3: Browser Compatibility for Download

**Impact:** Medium -- download via anchor click may behave differently across browsers
**Likelihood:** Low -- the `<a download="filename">` pattern is supported in all modern browsers (Chrome, Firefox, Safari 14+, Edge)

**Mitigation:** The `download` attribute is the standard approach. For any edge cases, users can right-click the chart canvas and "Save image as..." as a fallback (this is native browser behavior for canvas elements).

### Risk 4: Export Called Before Chart Renders

**Impact:** Low -- export returns `false`, no crash
**Likelihood:** Low -- button only shows when datasets exist

**Mitigation:** Multiple guard clauses: `hasDatasets` computed hides button, `handleDownload` checks `chartInstance`, `exportAsImage` checks `chartInstance`, `downloadImage` validates the data URL. Defense in depth.

### Risk 5: Timing Issue with Chart Animation

**Impact:** Low -- chart animation is 300ms; export during animation captures current frame
**Likelihood:** Low -- user is unlikely to click download within 300ms of chart rendering

**Mitigation:** Chart.js `toBase64Image()` captures the canvas at the current render state. Even during animation, it produces a valid image. If this becomes an issue, the animation duration could be set to 0 before export.

## Estimated Complexity

| Phase | Effort | Lines of Code | Risk |
|-------|--------|---------------|------|
| Phase 1: Export utilities | Small | ~70 (implementation) + ~120 (tests) | Low |
| Phase 2: defineExpose | Small | ~25 | Low |
| Phase 3: Download button UI | Small | ~35 (template/style) + ~20 (script) | Low |
| Phase 4: Test updates | Medium | ~120 (new tests) + ~15 (mock updates) | Low |
| Phase 5: App.vue integration | Small | ~20 | Low |
| **Total (Phases 1-4)** | **Small-Medium** | **~400 lines** | **Low** |

Overall task complexity: **Low**. All APIs are well-understood, the pattern is standard, and the existing codebase provides clear conventions to follow. No new dependencies are needed.

**Estimated implementation time:** 1-2 hours for Phases 1-4. Phase 5 is optional and adds ~15 minutes.
